---
layout: pages
title: æ•°æ®ç»“æ„ä¸ç®—æ³•å®éªŒæŒ‡å¯¼ä¹¦
author: è°­è‡ªè´¢
date: 2021-03-21 07:21:35
categories: æ•°æ®ç»“æ„ä¸ç®—æ³•
tags:
  - å·¥å…·
  - è®ºæ–‡
  - å…¬å¼
  - latex
---

## ã€Šæ•°æ®ç»“æ„ã€‹ä¸Šæœºå®éªŒå†…å®¹å’Œè¦æ±‚

é€šè¿‡ä¸Šæœºå®éªŒåŠ æ·±å¯¹è¯¾ç¨‹å†…å®¹çš„ç†è§£ï¼Œæé«˜ç¨‹åºè®¾è®¡ã€å¼€å‘åŠè°ƒè¯•èƒ½åŠ›ã€‚æœ¬å®éªŒæŒ‡å¯¼ä¹¦é€‚ç”¨äº16å­¦æ—¶ã€Šæ•°æ®ç»“æ„æ³•ã€‹å®éªŒè¯¾ï¼Œå®éªŒé¡¹ç›®å…·ä½“å†…å®¹å¦‚ä¸‹ï¼š

layout: pages
title: æ•°æ®ç»“æ„ä¸ç®—æ³•å®éªŒæŒ‡å¯¼ä¹¦
author: è°­è‡ªè´¢
date: 2021-03-21 07:21:35
categories: æ•°æ®ç»“æ„ä¸ç®—æ³•
tags:
  - æ•°æ®ç»“æ„
  - ç®—æ³•
  - Cè¯­è¨€
  - å®éªŒ

## å®éªŒæŠ¥å‘Šè¦æ±‚

> è¯·æŒ‰ç…§è¯„åˆ†æ ‡å‡†å’ŒæŠ¥å‘Šæ¨¡æ¿è¦æ±‚ï¼Œæäº¤å®éªŒæŠ¥å‘Šç”µå­ç‰ˆæ–‡ä»¶ã€‚

# ğŸ‘¦**å®éªŒä¸€ã€é¡ºåºè¡¨çš„å®ç°åŠåº”ç”¨**

## **ä¸€ã€å®éªŒç›®çš„**

äº†è§£å’ŒæŒæ¡çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨ç»“æ„ï¼›æŒæ¡ç”¨Cè¯­è¨€ä¸Šæœºè°ƒè¯•çº¿æ€§è¡¨çš„åŸºæœ¬æ–¹æ³•ï¼›æŒæ¡çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œï¼šæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ä»¥åŠçº¿æ€§è¡¨åˆå¹¶ç­‰è¿ç®—åœ¨é¡ºåºå­˜å‚¨ç»“æ„å’Œé“¾æ¥å­˜å‚¨ç»“æ„ä¸Šçš„è¿ç®—ï¼Œä»¥åŠå¯¹ç›¸åº”ç®—æ³•çš„æ€§èƒ½åˆ†æã€‚

## **äºŒã€å®éªŒè¦æ±‚**

ç»™å®šä¸€æ®µç¨‹åºä»£ç ï¼Œç¨‹åºä»£ç æ‰€å®Œæˆçš„åŠŸèƒ½ä¸ºï¼š

ï¼ˆ1ï¼‰å»ºç«‹ä¸€ä¸ªçº¿æ€§è¡¨ï¼›

ï¼ˆ2ï¼‰ä¾æ¬¡è¾“å…¥æ•°æ®å…ƒç´ 1,2,3,4,5,6,7,8,9,10ï¼›

ï¼ˆ3ï¼‰åˆ é™¤æ•°æ®å…ƒç´ 5ï¼›

ï¼ˆ4ï¼‰ä¾æ¬¡æ˜¾ç¤ºå½“å‰çº¿æ€§è¡¨ä¸­çš„æ•°æ®å…ƒç´ ã€‚å‡è®¾è¯¥çº¿æ€§è¡¨çš„æ•°æ®å…ƒç´ ä¸ªæ•°åœ¨æœ€åæƒ…å†µä¸‹ä¸ä¼šè¶…è¿‡100ä¸ªï¼Œè¦æ±‚ä½¿ç”¨é¡ºåºè¡¨ã€‚

ç¨‹åºä¸­æœ‰3å¤„é”™è¯¯çš„åœ°æ–¹ï¼Œæœ‰æ ‡è¯†ï¼Œå±äºé€»è¾‘é”™è¯¯ï¼Œå¯¹ç…§ä¹¦ä¸­çš„ä»£ç ä»”ç»†åˆ†æåï¼Œè¦æ±‚åŒå­¦ä»¬ä¿®æ”¹é”™è¯¯çš„ä»£ç ï¼Œä¿®æ”¹åä¸Šæœºè°ƒè¯•å¾—åˆ°æ­£ç¡®çš„è¿è¡Œç»“æœã€‚

## **ä¸‰ã€ç¨‹åºä»£ç **

```c
6 #include <stdio.h>
#include "stdlib.h"
#define MaxSize  100
typedef int DataType;

typedef struct
{
    DataType list[MaxSize];
    int size;
} SeqList;

void ListInitiate(SeqList *L)/*åˆå§‹åŒ–é¡ºåºè¡¨L*/
{
    L->size = 0;/*å®šä¹‰åˆå§‹æ•°æ®å…ƒç´ ä¸ªæ•°*/
}

int ListLength(SeqList L)/*è¿”å›é¡ºåºè¡¨Lçš„å½“å‰æ•°æ®å…ƒç´ ä¸ªæ•°*/
{
    return L.size;
}

int ListInsert(SeqList *L, int i, DataType x)
/*åœ¨é¡ºåºè¡¨Lçš„ä½ç½®iï¼ˆ0 â‰¤ i â‰¤ sizeï¼‰å‰æ’å…¥æ•°æ®å…ƒç´ å€¼x*/
/*æ’å…¥æˆåŠŸè¿”å›1ï¼Œæ’å…¥å¤±è´¥è¿”å›0*/
{
    int j;
    if(L->size >= MaxSize)
    {
        printf("é¡ºåºè¡¨å·²æ»¡æ— æ³•æ’å…¥! \\n");
        return 0;
    }
    else if(i < 0 || i > L->size )
    {
        printf("å‚æ•°iä¸åˆæ³•! \\n");
        return 0;
    }
    else
    { //æ­¤æ®µç¨‹åºæœ‰ä¸€å¤„é”™è¯¯
        for(j = L->size; j >= i; j--) L->list[j+1] = L->list[j];/*ä¸ºæ’å…¥åšå‡†å¤‡*/
        L->list[i] = x;/*æ’å…¥*/
        L->size ++;/*å…ƒç´ ä¸ªæ•°åŠ 1*/
        return 1;
    }
}

int ListDelete(SeqList *L, int i, DataType *x)
/*åˆ é™¤é¡ºåºè¡¨Lä¸­ä½ç½®iï¼ˆ0 â‰¤ i â‰¤ size - 1ï¼‰çš„æ•°æ®å…ƒç´ å€¼å¹¶å­˜æ”¾åˆ°å‚æ•°xä¸­*/
/*åˆ é™¤æˆåŠŸè¿”å›1ï¼Œåˆ é™¤å¤±è´¥è¿”å›0*/
{
    int j;
    if(L->size <= 0)
    {
        printf("é¡ºåºè¡¨å·²ç©ºæ— æ•°æ®å…ƒç´ å¯åˆ ! \\n");
        return 0;
    }
    else if(i < 0 || i > L->size-1)
    {
        printf("å‚æ•°iä¸åˆæ³•");
        return 0;
    }
    else
    {//æ­¤æ®µç¨‹åºæœ‰ä¸€å¤„é”™è¯¯

        *x = L->list[i];/*ä¿å­˜åˆ é™¤çš„å…ƒç´ åˆ°å‚æ•°xä¸­*/
        for(j = i +1; j <= L->size-1; j++) L->list[j-1] = L->list[j];/*ä¾æ¬¡å‰ç§»*/
        L->size--;/*æ•°æ®å…ƒç´ ä¸ªæ•°å‡1*/
        return 1;
    }
}

int ListGet(SeqList L, int i, DataType *x)
/*å–é¡ºåºè¡¨Lä¸­ç¬¬iä¸ªæ•°æ®å…ƒç´ çš„å€¼å­˜äºxä¸­ï¼ŒæˆåŠŸåˆ™è¿”å›1ï¼Œå¤±è´¥è¿”å›0*/
{
    if(i < 0 || i > L.size-1)
    {
        printf("å‚æ•°iä¸åˆæ³•! \\n");
        return 0;
    }
    else
    {
        *x = L.list[i];
        return 1;
    }
}

void ListMerge(SeqList L1,SeqList L2,SeqList *L3)
{
    int ai=0,bi=0;
    int i=0,j=0,k=0;
    ListInitiate(L3);
    while (i <= ListLength(L1)-1 && j <= ListLength(L2)-1)
    {
        ListGet(L1,i,&ai);
        ListGet(L2,j,&bi);
        if (ai<=bi)
        {
            ListInsert(L3,k++,ai);
            ++i;

        }
        else {
            ListInsert(L3, k++, bi);
            ++j;
        }
    }
    while(i<=ListLength(L1)-1)
    {
        ListGet(L1,i++,&ai);
        ListInsert(L3,++k,ai);
    }
    while (j<=ListLength(L2)-1)
    {
        ListGet(L2,j++,&bi);
        ListInsert(L3,k++,bi);
    }
}

int main(void)
{   SeqList myList;
    SeqList list;
    SeqList listAll;
    int i , x;
    ListInitiate(&myList);
    ListInitiate(&list);
    ListInitiate(&listAll);
    for(i = 0; i < 10; i++)
        ListInsert(&myList, i, i+1);
    ListDelete(&myList, 4, &x);
    for (int j = 0; j < 10; ++j) {
        ListInsert(&list,j,j+21);
    }
    ListMerge(myList,list,&listAll);
    for(i = 0; i < ListLength(myList); i++)
    {
        ListGet(myList,i,&x); //æ­¤æ®µç¨‹åºæœ‰ä¸€å¤„é”™è¯¯
        printf("%d\\n", x);
    }
    printf("\\n");
    for(i = 0; i < ListLength(list); i++)
    {
        ListGet(list,i,&x); //æ­¤æ®µç¨‹åºæœ‰ä¸€å¤„é”™è¯¯
        printf("%d\\n", x);
    }
    for (i = 0; i < ListLength(listAll); i++) {
        ListGet(listAll,i,&x);
        printf("%d\\n",x);
    }
}
```

### åˆå¹¶å‡½æ•°_WriteByLiyihan

```c
void ListMerge(SeqList L1,SeqList L2,SeqList *L3)
{
    int ai=0,bi=0;
    int i=0,j=0,k=0;
    ListInitiate(L3);
    while (i <= ListLength(L1)-1 && j <= ListLength(L2)-1)
    {
        ListGet(L1,i,&ai);
        ListGet(L2,j,&bi);
        if (ai<=bi)
        {
            ListInsert(L3,k++,ai);
            ++i;

        }
        else {
            ListInsert(L3, k++, bi);
            ++j;
        }
    }
    while(i<=ListLength(L1)-1)
    {
        ListGet(L1,i++,&ai);
        ListInsert(L3,++k,ai);
    }
    while (j<=ListLength(L2)-1)
    {
        ListGet(L2,j++,&bi);
        ListInsert(L3,k++,bi);
    }
}
```

## **å››ã€å®éªŒä»»åŠ¡**

1.æ”¹æ­£ä¸Šè¿°ç¨‹åºä¸­çš„é”™è¯¯ã€‚

2.ç¼–å†™åˆå¹¶å‡½æ•°ï¼Œå°†ä¸¤ä¸ªæœ‰åºçº¿æ€§è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæœ‰åºè¡¨å¹¶åœ¨ä¸»å‡½æ•°ä¸­åŠ ä»¥æµ‹è¯•ã€‚

3.å®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

# **å®éªŒäºŒ é“¾è¡¨çš„å®ç°åŠåº”ç”¨**

## **ä¸€ã€å®éªŒç›®çš„**

äº†è§£å’ŒæŒæ¡çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨ç»“æ„ï¼›æŒæ¡ç”¨Cè¯­è¨€ä¸Šæœºè°ƒè¯•çº¿æ€§è¡¨çš„åŸºæœ¬æ–¹æ³•ï¼›æŒæ¡çº¿æ€§è¡¨çš„åŸºæœ¬æ“ä½œï¼šæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ä»¥åŠçº¿æ€§è¡¨åˆå¹¶ç­‰è¿ç®—åœ¨é¡ºåºå­˜å‚¨ç»“æ„å’Œé“¾æ¥å­˜å‚¨ç»“æ„ä¸Šçš„è¿ç®—ï¼Œä»¥åŠå¯¹ç›¸åº”ç®—æ³•çš„æ€§èƒ½åˆ†æã€‚

## **äºŒã€å®éªŒè¦æ±‚**

ç»™å®šä¸€æ®µç¨‹åºä»£ç ï¼Œç¨‹åºä»£ç æ‰€å®Œæˆçš„åŠŸèƒ½ä¸ºï¼š

ï¼ˆ1ï¼‰å»ºç«‹ä¸€ä¸ªçº¿æ€§è¡¨ï¼›

ï¼ˆ2ï¼‰ä¾æ¬¡è¾“å…¥æ•°æ®å…ƒç´ 1,2,3,4,5,6,7,8,9,10ï¼›

ï¼ˆ3ï¼‰åˆ é™¤æ•°æ®å…ƒç´ 5ï¼›

ï¼ˆ4ï¼‰ä¾æ¬¡æ˜¾ç¤ºå½“å‰çº¿æ€§è¡¨ä¸­çš„æ•°æ®å…ƒç´ ã€‚å‡è®¾è¯¥çº¿æ€§è¡¨çš„æ•°æ®å…ƒç´ ä¸ªæ•°åœ¨æœ€åæƒ…å†µä¸‹ä¸ä¼šè¶…è¿‡100ä¸ªï¼Œè¦æ±‚ä½¿ç”¨å•é“¾è¡¨ã€‚

ç¨‹åºä¸­æœ‰3å¤„é”™è¯¯çš„åœ°æ–¹ï¼Œæœ‰æ ‡è¯†ï¼Œå±äºé€»è¾‘é”™è¯¯ï¼Œå¯¹ç…§ä¹¦ä¸­çš„ä»£ç ä»”ç»†åˆ†æåï¼Œè¦æ±‚åŒå­¦ä»¬ä¿®æ”¹é”™è¯¯çš„ä»£ç ï¼Œä¸Šæœºè°ƒè¯•å¹¶å¾—åˆ°æ­£ç¡®çš„è¿è¡Œç»“æœã€‚

## **ä¸‰ã€ç¨‹åºä»£ç ï¼š**

```c
#include <stdio.h>/*è¯¥æ–‡ä»¶åŒ…å«printf()ç­‰å‡½æ•°*/
#include <stdlib.h>/*è¯¥æ–‡ä»¶åŒ…å«exit()ç­‰å‡½æ•°*/
#include <malloc.h>/*è¯¥æ–‡ä»¶åŒ…å«malloc()ç­‰å‡½æ•°*/
typedef int DataType;/*å®šä¹‰DataTypeä¸ºint*/
typedef struct Node
{
	DataType data;
	struct Node *next;
} SLNode;

void ListInitiate(SLNode **head)/*åˆå§‹åŒ–*/
{
/*å¦‚æœæœ‰å†…å­˜ç©ºé—´ï¼Œç”³è¯·å¤´ç»“ç‚¹ç©ºé—´å¹¶ä½¿å¤´æŒ‡é’ˆheadæŒ‡å‘å¤´ç»“ç‚¹*/
	if((*head = (SLNode *)malloc(sizeof(SLNode))) == NULL) exit(1);
	(*head)->next = NULL;/*ç½®é“¾å°¾æ ‡è®°NULL */
}

int ListLength(SLNode *head)        /* å•é“¾è¡¨çš„é•¿åº¦*/
{
	SLNode *p = head;/*pæŒ‡å‘é¦–å…ƒç»“ç‚¹*/
	int size = 0;/*sizeåˆå§‹ä¸º0*/
	while(p->next != NULL)/*å¾ªç¯è®¡æ•°*/
	{
		p = p->next;
		size ++;
	}
	return size;
}
int ListInsert(SLNode *head, int i, DataType x)
/*åœ¨å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨headçš„æ•°æ®å…ƒç´ aiï¼ˆ0 â‰¤ i â‰¤ sizeï¼‰ç»“ç‚¹å‰*/
/*æ’å…¥ä¸€ä¸ªå­˜æ”¾æ•°æ®å…ƒç´ xçš„ç»“ç‚¹*/
{
	SLNode *p, *q;
	int j;
	p = head; /*pæŒ‡å‘é¦–å…ƒç»“ç‚¹*/
	j = -1;/*jåˆå§‹ä¸º-1*/
	while(p->next != NULL && j < i - 1) 
/*æœ€ç»ˆè®©æŒ‡é’ˆpæŒ‡å‘æ•°æ®å…ƒç´ ai-1ç»“ç‚¹*/
	{
		p = p->next;
		j++;
	}
	if(j != i - 1)
	{
		printf("æ’å…¥ä½ç½®å‚æ•°é”™ï¼");
		return 0;
	}
/*ç”Ÿæˆæ–°ç»“ç‚¹ç”±æŒ‡é’ˆqæŒ‡ç¤º*/
	if((q = (SLNode *)malloc(sizeof(SLNode))) == NULL) exit(1);
		q->data = x; 
//æ­¤æ®µç¨‹åºæœ‰ä¸€å¤„é”™è¯¯
	q->next = p->next;/*ç»™æŒ‡é’ˆq->nextèµ‹å€¼*/
	p->next = q;/*ç»™æŒ‡é’ˆp->nexté‡æ–°èµ‹å€¼*/
	return 1;
}
int ListDelete(SLNode *head, int i, DataType *x)
/*åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨headçš„æ•°æ®å…ƒç´ aiï¼ˆ0 â‰¤ i â‰¤ size - 1ï¼‰ç»“ç‚¹*/
/*åˆ é™¤ç»“ç‚¹çš„æ•°æ®å…ƒç´ åŸŸå€¼ç”±xå¸¦å›ã€‚åˆ é™¤æˆåŠŸæ—¶è¿”å›1ï¼›å¤±è´¥è¿”å›0*/
{
	SLNode *p, *s;
	int j;
	p = head; /*pæŒ‡å‘é¦–å…ƒç»“ç‚¹*/
	j = -1;/*jåˆå§‹ä¸º-1*/
while(p->next != NULL && p->next->next!= NULL && j < i - 1) 
/*æœ€ç»ˆè®©æŒ‡é’ˆpæŒ‡å‘æ•°æ®å…ƒç´ ai-1ç»“ç‚¹*/
	{
		p = p->next;
		j++;
	}
	if(j != i - 1)
	{
		printf("åˆ é™¤ä½ç½®å‚æ•°é”™ï¼");
		return 0;
}
	q= p->next; /*æŒ‡é’ˆsæŒ‡å‘æ•°æ®å…ƒç´ aiç»“ç‚¹*/
	*x = s->data;/*æŠŠæŒ‡é’ˆsæ‰€æŒ‡ç»“ç‚¹çš„æ•°æ®å…ƒç´ åŸŸå€¼èµ‹äºˆx*/
	p->next = s->next;/*æŠŠæ•°æ®å…ƒç´ aiç»“ç‚¹ä»å•é“¾è¡¨ä¸­åˆ é™¤*/
	free(s);/*é‡Šæ”¾æŒ‡é’ˆsæ‰€æŒ‡ç»“ç‚¹çš„å†…å­˜ç©ºé—´*/
	return 1;
}

int ListGet(SLNode *head, int i, DataType *x)
/*å–æ•°æ®å…ƒç´ aiå’Œåˆ é™¤å‡½æ•°ç±»åŒï¼Œåªæ˜¯ä¸åˆ é™¤æ•°æ®å…ƒç´ aiç»“ç‚¹*/
{
	SLNode *p;
	int j;
	p = head;
	j = -1;
	while(p->next != NULL && j < i)
	{
		p = p->next;j++;
	}
	if(j != i)
	{
		printf("å–å…ƒç´ ä½ç½®å‚æ•°é”™ï¼");
	return 0;
	}
	*x = p->data;
	return 1;
}
void Destroy(SLNode **head)
{
	SLNode *p, *p1;
	p = *head;
	while(p != NULL)
	{
		p1 = p;
		p = p->next;
		free(p1);
	}
	*head = NULL;
}

	void main(void)
{
	SLNode *head;
	int i , x;
	ListInitiate(&head);/*åˆå§‹åŒ–*/
	for(i = 0; i < 10; i++)
	{
		if(ListInsert(head, i, i+1) == 0) /*æ’å…¥10ä¸ªæ•°æ®å…ƒç´ */
		{
			printf("é”™è¯¯! \\n");
			rturn;
		}
	}
	if(ListDelete(head, 4, &x) == 0) /*åˆ é™¤æ•°æ®å…ƒç´ 5*/
	{
		printf("é”™è¯¯! \\n");
		return;
	}
	for(i = 0; i < ListLength(head); i++)
	{
	if(ListGet(head, i, &x) == 0) /*å–å…ƒç´ */
	{
		printf("é”™è¯¯! \\n");
		return;
	}
	else printf("%d   ", x);/*æ˜¾ç¤ºæ•°æ®å…ƒç´ */
	}
	Destroy(&head);
	}
```

## ä¸‰ã€**å®éªŒä»»åŠ¡**

1.æ”¹æ­£ä¸Šè¿°ç¨‹åºä¸­çš„é”™è¯¯ã€‚

2.ç¼–å†™åˆå¹¶å‡½æ•°ï¼Œå°†ä¸¤ä¸ªæœ‰åºçš„å•é“¾è¡¨åˆå¹¶æˆä¸€ä¸ªæœ‰åºå•é“¾è¡¨ã€‚

3.å®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

# **å®éªŒä¸‰ã€æ ˆçš„å®ç°åŠåº”ç”¨**

## **ä¸€ã€å®éªŒç›®çš„**

1.æŒæ¡æ ˆçš„å­˜å‚¨è¡¨ç¤ºå’Œå®ç°

2.æŒæ¡æ ˆçš„åŸºæœ¬æ“ä½œå®ç°ã€‚

3.æŒæ¡æ ˆåœ¨è§£å†³å®é™…é—®é¢˜ä¸­çš„åº”ç”¨ã€‚

## **äºŒã€å®éªŒè¦æ±‚**

é—®é¢˜æè¿°ï¼šè®¾è®¡ä¸€ä¸ªç¨‹åºï¼Œæ¼”ç¤ºç”¨ç®—ç¬¦ä¼˜å…ˆæ³•å¯¹ç®—æœ¯è¡¨è¾¾å¼æ±‚å€¼çš„è¿‡ç¨‹ã€‚åˆ©ç”¨ç®—ç¬¦ä¼˜å…ˆå…³ç³»ï¼Œå®ç°å¯¹ç®—æœ¯å››åˆ™æ··åˆè¿ç®—è¡¨è¾¾å¼çš„æ±‚å€¼ã€‚

ï¼ˆ1ï¼‰è¾“å…¥çš„å½¢å¼ï¼šè¡¨è¾¾å¼ï¼Œä¾‹å¦‚2*(3+4)#

åŒ…å«çš„è¿ç®—ç¬¦åªèƒ½æœ‰'+' ã€'-' ã€'*' ã€'/' ã€'('ã€ ')'ï¼Œâ€œ#â€ä»£è¡¨è¾“å…¥ç»“æŸç¬¦ï¼›

ï¼ˆ2ï¼‰è¾“å‡ºçš„å½¢å¼ï¼šè¿ç®—ç»“æœï¼Œä¾‹å¦‚2*(3+4)=14ï¼› ï¼ˆ3ï¼‰ç¨‹åºæ‰€èƒ½è¾¾åˆ°çš„åŠŸèƒ½ï¼šå¯¹è¡¨è¾¾å¼æ±‚å€¼å¹¶è¾“å‡ºã€‚

## **ä¸‰ã€è§£é¢˜å‚è€ƒæ€è·¯**

ä¸ºäº†å®ç°ç”¨æ ˆè®¡ç®—ç®—æ•°è¡¨è¾¾å¼çš„å€¼ï¼Œéœ€è®¾ç½®ä¸¤ä¸ªå·¥ä½œæ ˆï¼šç”¨äºå­˜å‚¨è¿ç®—ç¬¦çš„æ ˆopterï¼Œä»¥åŠç”¨äºå­˜å‚¨æ“ä½œæ•°åŠä¸­é—´ç»“æœçš„æ ˆopndã€‚

ç®—æ³•åŸºæœ¬æ€æƒ³å¦‚ä¸‹ï¼š

ï¼ˆ1ï¼‰é¦–å…ˆå°†æ“ä½œæ•°æ ˆopndè®¾ä¸ºç©ºæ ˆï¼Œè€Œå°†'#'ä½œä¸ºè¿ç®—ç¬¦æ ˆopterçš„æ ˆåº•å…ƒç´ ï¼Œè¿™æ ·çš„ç›®çš„æ˜¯åˆ¤æ–­è¡¨è¾¾å¼æ˜¯å¦æ±‚å€¼å®Œæ¯•ã€‚

ï¼ˆ2ï¼‰ä¾æ¬¡è¯»å…¥è¡¨è¾¾å¼çš„æ¯ä¸ªå­—ï¼Œè¡¨è¾¾å¼é¡»ä»¥'#'ç»“ï¼Œè¯»å…¥å­—ç¬¦è‹¥æ˜¯æ“ä½œæ•°åˆ™å…¥æ ˆopndï¼Œè¯»å…¥å­—ç¬¦è‹¥æ˜¯è¿ç®—ç¬¦ï¼Œåˆ™å°†æ­¤è¿ç®—ç¬¦cä¸opterçš„æ ˆé¡¶å…ƒç´ topæ¯”è¾ƒä¼˜å…ˆçº§åæ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œå…·ä½“æ“ä½œå¦‚ä¸‹ï¼š

1. è‹¥topçš„ä¼˜å…ˆçº§å°äºcï¼Œå³top<cï¼Œåˆ™å°†cç›´æ¥å…¥æ ˆopterï¼Œå¹¶è¯»å…¥ä¸‹ä¸€å­—ç¬¦èµ‹å€¼ç»™cï¼›
2. è‹¥topçš„ä¼˜å…ˆçº§ç­‰äºcï¼Œå³top=cï¼Œåˆ™å¼¹å‡ºopterçš„æ ˆé¡¶å…ƒç´ ï¼Œå¹¶è¯»å…¥ä¸‹ä¸€å­—ç¬¦èµ‹å€¼ç»™cï¼Œè¿™ä¸€æ­¥ç›®çš„æ˜¯è¿›è¡Œæ‹¬å·æ“ä½œ;
3. è‹¥topä¼˜å…ˆçº§é«˜äºcï¼Œå³top>cï¼Œåˆ™è¡¨æ˜å¯ä»¥è®¡ç®—ï¼Œæ­¤æ—¶å¼¹å‡ºopndçš„æ ˆé¡¶ä¸¤ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”å¼¹å‡ºopteræ ˆé¡¶çš„çš„è¿ç®—ç¬¦ï¼Œè®¡ç®—åå°†ç»“æœæ”¾å…¥æ ˆopndä¸­ã€‚ç›´è‡³opterçš„æ ˆé¡¶å…ƒç´ å’Œå½“å‰è¯»å…¥çš„å­—ç¬¦å‡ä¸º'#'ï¼Œæ­¤æ—¶æ±‚å€¼ç»“æŸã€‚

ç®—ç¬¦é—´çš„ä¼˜å…ˆå…³ç³»å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼ˆè¡¨æ¥æºï¼šä¸¥è”šæ•ã€Šæ•°æ®ç»“æ„ã€‹ï¼‰ï¼š

![è¡¨æ¥æºï¼šä¸¥è”šæ•ã€Šæ•°æ®ç»“æ„ã€‹](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072431.png)

è¡¨ä¸­éœ€è¦æ³¨æ„çš„æ˜¯Î¸1ä¸ºopterçš„æ ˆé¡¶å…ƒç´ ï¼ŒÎ¸2ä¸ºä»è¡¨è¾¾å¼ä¸­è¯»å–çš„æ“ä½œç¬¦ï¼Œæ­¤ä¼˜å…ˆçº§è¡¨å¯ä»¥ç”¨äºŒç»´æ•°ç»„å®ç°ã€‚

å›¾ä¾‹ï¼š

![è¡¨è¾¾å¼æ±‚å€¼](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072444.png)

æ¯”è¾ƒç®—ç¬¦ä¼˜å…ˆå…³ç³»ä»£ç ç¤ºä¾‹ï¼š

```c
1.	int getIndex(char theta)   //è·å–thetaæ‰€å¯¹åº”çš„ç´¢å¼•  
2.	{  
3.	    int index = 0;  
4.	    switch (theta)  
5.	    {  
6.	    case '+':
7.	        index = 0;  
8.	        break;  
9.	    case '-':  
10.	        index = 1;  
11.	        break;  
12.	    case '*':  
13.	        index = 2;  
14.	        break;  
15.	    case '/':  
16.	        index = 3;  
17.	        break;  
18.	    case '(':  
19.	        index = 4;  
20.	        break;  
21.	    case ')':  
22.	        index = 5;  
23.	        break;  
24.	    case '#':  
25.	        index = 6;  
26.	    default:break;  
27.	    }  
28.	    return index;  
29.	}  
30.	  
31.	char getPriority(char theta1, char theta2)   //è·å–theta1ä¸theta2ä¹‹é—´çš„ä¼˜å…ˆçº§  
32.	{  
33.	    const char priority[][7] =     //ç®—ç¬¦é—´çš„ä¼˜å…ˆçº§å…³ç³»  
34.	    {  
35.	        { '>','>','<','<','<','>','>' },  
36.	        { '>','>','<','<','<','>','>' },  
37.	        { '>','>','>','>','<','>','>' },  
38.	        { '>','>','>','>','<','>','>' },  
39.	        { '<','<','<','<','<','=','0' },  
40.	        { '>','>','>','>','0','>','>' },  
41.	        { '<','<','<','<','<','0','=' },  
42.	    };  
43.	  
44.	    int index1 = getIndex(theta1);  
45.	    int index2 = getIndex(theta2);  
46.	    return priority[index1][index2];  
47.	}
```

## **å››ã€å®éªŒä»»åŠ¡**

è®¤çœŸé˜…è¯»ä¸ç†è§£å®éªŒå†…å®¹çš„å…·ä½“è¦æ±‚ï¼Œå‚è€ƒæ•™æç›¸å…³ç« èŠ‚ï¼Œç»“åˆå®éªŒå†…å®¹çš„è¦æ±‚ï¼Œç¼–å†™å®éªŒç¨‹åºå¹¶ä¸Šæœºè°ƒè¯•ä¸æµ‹è¯•ï¼Œå®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

## äº”ã€å®éªŒæ€è·¯

### **[æ ˆçš„å®šä¹‰](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d)**

åˆ›å»ºä¸¤ä¸ªç»“æ„ä½“ï¼Œä¸€ä¸ªåšæ ˆï¼Œä¸€ä¸ªæ˜¯æ ˆçš„èŠ‚ç‚¹

```c
typedef struct node
{
    int data;
    struct node *next;
}Node;

typedef struct stack
{
    Node *top;
    int count;
}Stack;
```

### **[æ ˆçš„æ“ä½œ](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d)**

åŒ…æ‹¬æ ˆçš„åŸºæœ¬æ“ä½œ

1. æ ˆçš„åˆå§‹åŒ–
2. æ ˆç©ºçš„åˆ¤æ–­
3. å‹æ ˆ
4. å‡ºæ ˆ
5. å–æ ˆé¡¶å…ƒç´ 
6. æ¸…ç©ºæ ˆ

```c
//åˆå§‹åŒ–æ ˆ
int InitStack(Stack *s)
{
    s->top = NULL;
    s->count= 0;
    return OK;
}

//åˆ¤ç©ºæ ˆ
int EmptyStack(Stack *s)
{
    return (s->count == 0) ? OK : ERROR;
}

//å‹æ ˆ
int Push(Stack *s, int e)
{
    Node *p = (Node *)malloc(sizeof(Node));
    if(p == NULL)
    {
        return ERROR;
    }
    p->data = e;
    p->next = s->top;
    s->top = p;
    s->count++;

    return OK;
}

//å–æ ˆé¡¶å…ƒç´ 
int GetTop(Stack *s)
{
    if(NULL == s->top)
    {
        return ERROR;
    }

    return (s->top->data);
}

//å‡ºæ ˆ
int Pop(Stack *s)
{
    int e;
    if(NULL == s->top)
    {
        return ERROR;
    }

    Node *p = s->top;
    e = p->data;
    s->top = p->next;
    free(p);
    s->count--;

    return e;
}

//æ¸…ç©ºæ ˆ
int ClearStack(Stack *s)
{
    if(s->count <= 0){
        printf("æ ˆå·²ç©º");
        return ERROR;
    }
    Node *p = s->top;
    while(s->count > 0)
    {
        p=s->top;
        s->top=s->top->next;
        free(p);
        s->count--;
    }

    s->top==NULL;
    return OK;
}
```

### **[ç¬¦å·ä¼˜å…ˆçº§åˆ¤æ–­å‡½æ•°](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d)**

```c
int Priority(char s)
{
    switch(s)
    {
        case '(':
            return 3;
        case '*':
        case '/':
            return 2;
        case '+':
        case '-':
            return 1;
        default:
            return 0;
    }
}
```

### **[ä¸»å‡½æ•°æ€è·¯1](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d)**

1. åˆ¤æ–­ç¬¦å·è¿˜æ˜¯æ•°å­—ï¼Œæ•°å­—ç›´æ¥å…¥æ ˆ
2. åˆ¤æ–­ç¬¦å·
   1. å¦‚æœæ˜¯ï¼ˆç¬¦å·æ ˆä¸ºç©º||ç¬¦å·æ ˆæ ˆé¡¶ä¸º'('&&å½“å‰ç¬¦å·ä¸æ˜¯')'||æ ˆé¡¶ä¼˜å…ˆçº§ä½äºå½“å‰ç¬¦å·),åˆ™å…¥æ ˆä¸è®¡ç®—
   2. å¦‚æœ'()'å†…æ— å…¶ä»–è¿ç®—ç¬¦ï¼Œå³æœ€æ ˆé¡¶æ˜¯ï¼ˆå½“å‰æ“ä½œç¬¦å·æ˜¯ï¼‰ï¼Œç›´æ¥ï¼ˆå‡ºæ ˆ
   3. å¦‚æœï¼ˆå­—ç¬¦ä¸²æ‰«æå®Œæˆä¸”ç¬¦å·æ ˆä¸ä¸ºç©ºï¼‰||(å½“å‰è¿ç®—ç¬¦ä¼˜å…ˆçº§ä½äºæ ˆé¡¶å…ƒç´ )

```c
int main() {
    Stack num, opt;
    char l = '*';
    char str[100] = {0};
    int i = 0, tmp = 0, j;

    if (InitStack(&num) != OK || InitStack(&opt) != OK) {
        printf("Init Failure!\\n");
        exit(1);
    }

    while(l != '#'){
        printf("Please Input Operator :\\n");
        scanf("%s", str);
        if(str[0]=='#')return 0;
        while (str[i] != '\\0' || EmptyStack(&opt) != OK) {
            if (str[i] >= '0' && str[i] <= '9') {
                tmp = tmp * 10 + str[i] - '0';
                i++;
                if (str[i] < '0' || str[i] > '9') {
                    Push(&num, tmp);
                    tmp = 0;
                }
            } else {
                //ç¬¦å·æ ˆä¸ºç©º
                //ç¬¦å·æ ˆæ ˆé¡¶ä¸º'('&&å½“å‰ç¬¦å·ä¸æ˜¯')'
                //æ ˆé¡¶ä¼˜å…ˆçº§ä½äºå½“å‰ç¬¦å·
                if ((EmptyStack(&opt) == OK) || (GetTop(&opt) == '(' && str[i] != ')') || Priority(str[i]) > Priority(GetTop(&opt)))//è¿›æ ˆä¸å‚ä¸è¿ç®—
                {
                    Push(&opt, str[i]);
                    i++;
                    continue;
                }
                //'()'å†…æ— å…¶ä»–è¿ç®—ç¬¦
                if (GetTop(&opt) == '(' && str[i] == ')')//å‡ºæ ˆä¸å‚ä¸è¿ç®—
                {
                    Pop(&opt);
                    i++;
                    continue;
                }
                //
                if ((str[i] == '\\0' && EmptyStack(&opt) != OK) || (str[i] == ')' && GetTop(&opt) != '(') || Priority(str[i]) <= Priority(GetTop(&opt)))//å‡ºæ ˆå¹¶å‚ä¸è¿ç®—
                {
                    switch (Pop(&opt)) {
                        case '+':
                            Push(&num, Pop(&num) + Pop(&num));
                            break;
                        case '-':
                            j = Pop(&num);
                            Push(&num, Pop(&num) - j);
                            break;
                        case '*':
                            Push(&num, Pop(&num) * Pop(&num));
                            break;
                        case '/':
                            j = Pop(&num);
                            Push(&num, Pop(&num) / j);
                    }
                    continue;
                }
            }
        }

        printf("%d", Pop(&num));
        printf("\\n");
        i=0;

    }
    return 0;
}
```

### **[ä¸»å‡½æ•°æ€è·¯2ï¼šæ•°æ®ç»“æ„æŒ‡å¯¼ä¹¦è¦æ±‚](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d)**

1. é¦–å…ˆåˆ›å»ºä¸¤ä¸ªæ ˆopndã€opterï¼Œè®¾ä¸ºopndä¸ºç©ºæ ˆï¼Œè€Œå°†'#'ä½œä¸ºè¿ç®—ç¬¦æ ˆopterçš„æ ˆåº•å…ƒç´ ï¼Œä»¥åˆ¤æ–­è¡¨è¾¾å¼æ˜¯å¦æ±‚å€¼å®Œæ¯•ã€‚
2. ä¾æ¬¡è¯»å…¥è¡¨è¾¾å¼çš„æ¯ä¸ªå­—ï¼Œè¡¨è¾¾å¼é¡»ä»¥'#'ç»“ï¼Œè¯»å…¥å­—ç¬¦è‹¥æ˜¯æ“ä½œæ•°åˆ™å…¥æ ˆopndï¼Œè¯»å…¥å­—ç¬¦è‹¥æ˜¯è¿ç®—ç¬¦ï¼Œåˆ™å°†æ­¤è¿ç®—ç¬¦cä¸opterçš„æ ˆé¡¶å…ƒç´ topæ¯”è¾ƒä¼˜å…ˆçº§åæ‰§è¡Œç›¸åº”çš„æ“ä½œï¼Œå…·ä½“æ“ä½œå¦‚ä¸‹ï¼š
   1. è‹¥topçš„ä¼˜å…ˆçº§å°äºcï¼Œå³top<cï¼Œåˆ™å°†cç›´æ¥å…¥æ ˆopterï¼Œå¹¶è¯»å…¥ä¸‹ä¸€å­—ç¬¦èµ‹å€¼ç»™cï¼›
   2. è‹¥topçš„ä¼˜å…ˆçº§ç­‰äºcï¼Œå³top=cï¼Œåˆ™å¼¹å‡ºopterçš„æ ˆé¡¶å…ƒç´ ï¼Œå¹¶è¯»å…¥ä¸‹ä¸€å­—ç¬¦èµ‹å€¼ç»™cï¼Œè¿™ä¸€æ­¥ç›®çš„æ˜¯è¿›è¡Œæ‹¬å·æ“ä½œ;
   3. è‹¥topä¼˜å…ˆçº§é«˜äºcï¼Œå³top>cï¼Œåˆ™è¡¨æ˜å¯ä»¥è®¡ç®—ï¼Œæ­¤æ—¶å¼¹å‡ºopndçš„æ ˆé¡¶ä¸¤ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”å¼¹å‡ºopteræ ˆé¡¶çš„çš„è¿ç®—ç¬¦ï¼Œè®¡ç®—åå°†ç»“æœæ”¾å…¥æ ˆopndä¸­ã€‚ç›´è‡³opterçš„æ ˆé¡¶å…ƒç´ å’Œå½“å‰è¯»å…¥çš„å­—ç¬¦å‡ä¸º'#'ï¼Œæ­¤æ—¶æ±‚å€¼ç»“æŸã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#define OK     1
#define ERROR  0
#define MAX_LINE 100

typedef struct nodeNum
{
    int data;
    struct node *next;
}Node;

typedef struct stack
{
    Node *top;
    int count;
}Stack;

//åˆå§‹åŒ–æ ˆ
int InitStack(Stack *l)
{
    l->top = NULL;
    l->count= 0;
    return OK;
}

//åˆ¤ç©ºæ ˆ
int EmptyStack(Stack *s)
{
    return (s->count == 0) ? OK : ERROR;
}

//å‹æ ˆ
int Push(Stack *s, int e)
{
    Node *p = (Node *)malloc(sizeof(Node));
    if(p == NULL)
    {
        return ERROR;
    }
    p->data = e;
    p->next = s->top;
    s->top = p;
    s->count++;

    return OK;
}

//å–æ ˆé¡¶å…ƒç´ 
int GetTop(Stack *s)
{
    if(NULL == s->top)
    {
        return ERROR;
    }

    return (s->top->data);
}

//ç¬¦å·ä¼˜å…ˆçº§åˆ¤æ–­
int Priority(char s)
{
    switch(s)
    {
        case '(':
            return 3;
        case '*':
        case '/':
            return 2;
        case '+':
        case '-':
            return 1;
        case '#':
            return 0;
        default:
            return -1;
    }
}

//å‡ºæ ˆ
int Pop(Stack *s)
{
    int e;
    if(NULL == s->top)
    {
        return ERROR;
    }

    Node *p = s->top;
    e = p->data;
    s->top = p->next;
    free(p);
    s->count--;

    return e;
}

//æ¸…ç©ºæ ˆ
int ClearStack(Stack *s)
{
    if(s->count <= 0){
        printf("æ ˆå·²ç©º");
        return ERROR;
    }
    Node *p = s->top;
    while(s->count > 0)
    {
        p=s->top;
        s->top=s->top->next;
        free(p);
        s->count--;
    }

    s->top==NULL;
    return OK;
}

int main(){
    char str[MAX_LINE] = {"123"};
    int i=0,temp=0,j=0;
    Stack opnd,opter;

    if(InitStack(&opnd) != OK || InitStack(&opter) != OK){
        printf("åˆå§‹åŒ–é”™è¯¯ï¼Œè¯·å…³é—­åé‡è¯•");
        exit(1);
    }
    Push(&opter,'#');

    do{
        printf("è¯·è¾“å…¥è®¡ç®—è¡¨è¾¾å¼,å¹¶ä»¥#ç»“å°¾\\n");
        scanf("%s",str);
    }while(str[0]== '#'|| str[strlen(str)-1] != '#');

    while(str[i] != '#' || GetTop(&opter) != '#')
    {
        if(str[i] >= '0' && str[i] <= '9')
        {
            temp = temp * 10 + str[i] - '0';
            i++;
            if(str[i] < '0' || str[i] > '9')
            {
                Push(&opnd,temp);
                temp = 0;
            }
        }else{
            //ç¬¦å·æ ˆæ ˆåº•æ˜¯#
            //ç¬¦å·æ ˆæ ˆé¡¶ä¸º'('&&å½“å‰ç¬¦å·ä¸æ˜¯')'
            //æ ˆé¡¶ä¼˜å…ˆçº§ä½äºå½“å‰ç¬¦å·
            //è¿›æ ˆä¸å‚ä¸è¿ç®—
            if ((GetTop(&opter) == '#') || (GetTop(&opter) == '(' && str[i] != ')') || Priority(str[i]) > Priority(GetTop(&opter)))
            {
                Push(&opter, str[i]);
                i++;
                continue;
            }
            //'()'å†…æ— å…¶ä»–è¿ç®—ç¬¦
            //å‡ºæ ˆä¸å‚ä¸è¿ç®—
            if (GetTop(&opter) == '(' && str[i] == ')')
            {
                Pop(&opter);
                i++;
                continue;
            }
            //
            //å‡ºæ ˆè¿ç®—
            if ((str[i] == '#' && GetTop(&opter) != '#') || (str[i] == ')' && GetTop(&opter) != '(') || Priority(str[i]) <= Priority(GetTop(&opter)))
            {
                switch (Pop(&opter)) {
                    case '+':
                        Push(&opnd, Pop(&opnd) + Pop(&opnd));
                        break;
                    case '-':
                        j = Pop(&opnd);
                        Push(&opnd, Pop(&opnd) - j);
                        break;
                    case '*':
                        Push(&opnd, Pop(&opnd) * Pop(&opnd));
                        break;
                    case '/':
                        j = Pop(&opnd);
                        Push(&opnd, Pop(&opnd) / j);
                }
                continue;
            }
        }
    }

    printf("%d", Pop(&opnd));
    printf("\\n");
    return 0;

}
```

# **å®éªŒå››ã€é˜Ÿåˆ—çš„å®ç°åŠåº”ç”¨**

> **ä¸€ã€å®éªŒç›®çš„**

> 1.æŒæ¡é˜Ÿåˆ—çš„å­˜å‚¨è¡¨ç¤ºå’Œå®ç°ã€‚

> 2.æŒæ¡é˜Ÿåˆ—çš„åŸºæœ¬æ“ä½œå®ç°ã€‚

> 3.æŒæ¡é˜Ÿåˆ—åœ¨è§£å†³å®é™…é—®é¢˜ä¸­çš„åº”ç”¨ã€‚

> **äºŒã€å®éªŒè¦æ±‚**

åˆ©ç”¨é˜Ÿåˆ—æ¨¡æ‹ŸæœåŠ¡å°å‰çš„æ’é˜Ÿç°è±¡é—®é¢˜ã€‚

æŸé“¶è¡Œæœ‰ä¸€ä¸ªå®¢æˆ·åŠç†ä¸šåŠ¡ç«™ï¼Œåœ¨å•ä½æ—¶é—´å†…éšæœºåœ°æœ‰å®¢æˆ·åˆ°è¾¾ï¼Œè®¾æ¯ä½å®¢æˆ·çš„ä¸šåŠ¡åŠç†æ—¶é—´æ˜¯æŸä¸ªèŒƒå›´çš„éšæœºå€¼ã€‚è®¾åªæœ‰ä¸€ä¸ªçª—å£ï¼Œä¸€ä½ä¸šåŠ¡äººå‘˜ï¼Œè¦æ±‚ç¨‹åºæ¨¡æ‹Ÿç»Ÿè®¡åœ¨è®¾å®šæ—¶é—´å†…ï¼Œä¸šåŠ¡äººå‘˜çš„æ€»ç©ºé—²æ—¶é—´å’Œå®¢æˆ·çš„å¹³å‡ç­‰å¾…æ—¶é—´ã€‚å‡å®šæ¨¡æ‹Ÿæ•°æ®å·²æŒ‰å®¢æˆ·åˆ°è¾¾çš„å…ˆåé¡ºåºä¾æ¬¡å­˜äºæŸä¸ªæ­£æ–‡æ•°æ®æ–‡ä»¶ä¸­ï¼Œå¯¹åº”æ¯ä½å®¢æˆ·æœ‰ä¸¤ä¸ªæ•°æ®ï¼šåˆ°è¾¾æ—¶é—´å’Œéœ€è¦åŠç†ä¸šåŠ¡çš„æ—¶é—´ï¼Œæ–‡æœ¬æ–‡ä»¶å†…å®¹å¦‚ï¼š10 20 10 10 45 5 55 10 58 15 65 10

## ä¸‰ã€**è§£é¢˜å‚è€ƒæ€è·¯**

ä¸æ ˆç›¸å¯¹åº”ï¼Œé˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºçš„çº¿æ€§è¡¨ã€‚å®ƒåªå…è®¸åœ¨è¡¨çš„ä¸€ç«¯è¿›è¡Œæ’å…¥ï¼Œè€Œåœ¨å¦ä¸€ç«¯è¿›è¡Œåˆ é™¤å…ƒç´ ã€‚å…è®¸æ’å…¥çš„ä¸€ç«¯ç§°é˜Ÿå°¾ï¼Œå…è®¸åˆ é™¤çš„ä¸€ç«¯ç§°é˜Ÿå¤´ã€‚æ’å…¥ä¸åˆ é™¤åˆ†åˆ«ç§°ä¸ºå…¥é˜Ÿä¸å‡ºé˜Ÿã€‚é˜Ÿåˆ—ç¤ºæ„å›¾å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

### ä¸€ã€æ•°æ®æè¿°ï¼ˆç»“æ„ä½“å®šä¹‰ï¼‰

![æ•°æ®æè¿°ï¼ˆç»“æ„ä½“å®šä¹‰ï¼‰](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072551.png)

```c
typedef struct{
  int arrive;
  int treat;//å®¢æˆ·çš„ä¿¡æ¯ç»“æ„
}QNODEï¼›
    
typedef struct node{
	QNODE data;
	Struct node *next;//é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¿¡æ¯
}LNODE,*QueuePtr;

typedef  struct{ //é“¾é˜Ÿåˆ—ç±»å‹
  QueuePtr   front ;  //é˜Ÿå¤´æŒ‡é’ˆ    
  QueuePtr   rear ;  //é˜Ÿå°¾æŒ‡é’ˆ
} LinkQueue;
```

### äºŒã€å­˜å–æ“ä½œï¼ˆé˜Ÿåˆ—æ“ä½œå‡½æ•°ï¼‰

```c
/*
 * å‡½æ•°åŠŸèƒ½ï¼šé˜Ÿåˆ—åˆå§‹åŒ–
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 */
int InitQueue(LinkQueue *Q){
    QueuePtr p =(QueuePtr)malloc(sizeof(LNODE));
    if (p == NULL){
        printf("åˆå§‹åŒ–å¤±è´¥\\n");
        return ERROR;
    }
    Q->rear = Q->front = p;
    Q->front->next = NULL;
    return OK;
}
/*
 * å‡½æ•°åŠŸèƒ½ï¼šå…¥é˜Ÿ
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ å…¥é˜Ÿæ•°æ®
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 * */
int EnQueue(LinkQueue* Q,QNODE data){
    QueuePtr p =(QueuePtr)malloc(sizeof(LNODE));
    p->data = data;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
/* å‡½æ•°åŠŸèƒ½ï¼šå‡ºé˜Ÿ
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ å–å€¼å˜é‡æŒ‡é’ˆ
 * ä¼ å…¥å‚æ•°ï¼šæ— 
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 * */
int DeQueue(LinkQueue *Q,QNODE *e){
    if (Q->front == Q->rear) {
        printf("é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ é™¤å¤±è´¥\\n");
        return ERROR;
    }
    LNODE* p;
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p)Q->rear = Q->front;
    free(p);
    return OK;
}
```

## ä¸‰ã€ä¸»å‡½æ•°æµç¨‹

![ä¸»å‡½æ•°æµç¨‹](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072634.png)

```c
{ 
	è®¾ç½®ç»Ÿè®¡åˆå€¼ï¼šä¸šåŠ¡å‘˜ç­‰å¾…æ—¶é—´ï¼Œå®¢æˆ·æ€»çš„å¾…æ—¶é—´ï¼Œå®¢æˆ·æ€»äººæ•°ç­‰

	è®¾ç½®å½“å‰æ—¶é’Ÿclockæ—¶é—´ä¸º0ï¼›
	//ç”¨å˜é‡clockæ¥æ¨¡æ‹Ÿå½“å‰æ—¶é—´.

	æ‰“å¼€æ•°æ®æ–‡ä»¶ï¼Œå‡†å¤‡è¯»ï¼›
	printf("\\nenterfilename:");
  scanf("%s",Fname);/*è¾“å…¥è£…å®¢æˆ·æ¨¡æ‹Ÿæ•°æ®çš„æ–‡ä»¶çš„æ–‡ä»¶å*/

	è¯»å…¥ç¬¬ä¸€ä½å®¢æˆ·ä¿¡æ¯äºæš‚å­˜å˜é‡ä¸­ï¼›
	//æ–‡ä»¶è¯»æ“ä½œhave= fscanf(fp,"%d %d",&temp.arrive,&temp.treat);

	//çº¦å®šæ¯è½®å¾ªç¯ï¼Œå¤„ç†å®Œä¸€ä½å®¢æˆ·
	do{
			if(ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œå¹¶ä¸”è¿˜æœ‰å®¢æˆ·){ 

				ç´¯è®¡ä¸šåŠ¡å‘˜æ€»ç­‰å¾…æ—¶é—´ï¼›

				æ—¶é’Ÿæ¨è¿›åˆ°æš‚å­˜å˜é‡ä¸­çš„å®¢æˆ·çš„åˆ°è¾¾æ—¶é—´ï¼›//clock=temp.arrive

				æš‚å­˜å˜é‡ä¸­çš„å®¢æˆ·ä¿¡æ¯è¿›é˜Ÿï¼›

				è¯»å–ä¸‹ä¸€ä½å®¢æˆ·ä¿¡æ¯äºæš‚å­˜å˜é‡ï¼›

}

ä»ç­‰å¾…é˜Ÿåˆ—å‡ºé˜Ÿä¸€ä½å®¢æˆ·ï¼›

ç´¯è®¡å®¢æˆ·äººæ•°ï¼›

å°†è¯¥å®¢æˆ·çš„ç­‰å¾…æ—¶é—´ç´¯è®¡åˆ°å®¢æˆ·çš„æ€»ç­‰å¾…æ—¶é—´ï¼›//=å½“å‰æ—¶é—´-å®¢æˆ·åˆ°è¾¾æ—¶é—´

è®¾å®šå½“å‰å®¢æˆ·çš„ä¸šåŠ¡åŠç†ç»“æŸæ—¶é—´ï¼›//=å½“å‰æ—¶é—´+å®¢æˆ·åŠç†ä¸šåŠ¡æ‰€éœ€æ—¶é—´

while(ä¸‹ä¸€ä½å®¢æˆ·çš„åˆ°è¾¾æ—¶é—´åœ¨å½“å‰å®¢æˆ·å¤„ç†ç»“æŸä¹‹å‰ï¼Œå¹¶ä¸”è¿˜æœ‰å®¢æˆ·)

{

		æš‚å­˜å˜é‡ä¸­çš„å®¢æˆ·ä¿¡æ¯è¿›é˜Ÿï¼›

è¯»å–ä¸‹ä¸€ä½å®¢æˆ·ä¿¡æ¯äºæš‚å­˜å˜é‡ï¼›

}

		æ—¶é’Ÿæ¨è¿›åˆ°å½“å‰å®¢æˆ·åŠç†ç»“æŸæ—¶é—´ï¼›

}while(è¿˜æœ‰æœªå¤„ç†çš„å®¢æˆ·)ï¼›//ç­‰å¾…é˜Ÿåˆ—ä¸ä¸ºç©ºæˆ–è€…è¿˜æœ‰å®¢æˆ·ï¼ˆhave==2ï¼‰

è®¡ç®—ç»Ÿè®¡ç»“æœï¼Œå¹¶è¾“å‡ºï¼›
void main(){
    QNODE curret,temp;
    int dwait=0,clock=0,wait=0,count=0,have=0,finish;
    LinkQueue BankQueue;
    InitQueue(&BankQueue);
    printf("\\nè¯·è¾“å…¥è¯»å–æ–‡ä»¶çš„æ–‡ä»¶å\\n");
    scanf("%s",file_name);
    fopen_s(&fp,file_name,"r");
    while (fp == NULL){
        printf("å½“å‰ç›®å½•æ²¡æœ‰æ­¤æ–‡ä»¶ï¼Œè¯·é‡æ–°è¾“å…¥æ–‡ä»¶å");
        scanf("%s",file_name);
    }
    have = fscanf_s(fp,"%d %d",&temp.arrive,&temp.treat);
    do{        //çº¦å®šæ¯è½®å¾ªç¯ï¼Œå¤„ç†ä¸€ä¸ªå®¢æˆ·
        if(BankQueue.front->next == NULL&&have==2)     //ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œä½†è¿˜æœ‰å®¢æˆ·
        {
            dwait+=temp.arrive-clock;  //ç´¯è®¡ä¸šåŠ¡å‘˜æ€»ç­‰å¾…æ—¶é—´
            clock=temp.arrive;
            EnQueue(&BankQueue,temp); //æš‚å­˜å˜é‡ä¸­å®¢æˆ·çš„ä¿¡æ¯è¿›é˜Ÿ
            have=fscanf(fp,"%d %d",&temp.arrive,&temp.treat);
        }
        count++;
        DeQueue(&BankQueue,&curret); //å‡ºé˜Ÿä¸€ä½å®¢æˆ·ä¿¡æ¯
        wait+=clock-curret.arrive;  //ç´¯è®¡åˆ°å®¢æˆ·çš„ç­‰å¾…æ—¶é—´
        finish=clock+curret.treat;  //è®¾å®šä¸šåŠ¡åŠç†ç»“æŸæ—¶é—´
        while(have==2&&temp.arrive<=finish)   //ä¸‹ä¸€ä½å®¢æˆ·åˆ°è¾¾æ—¶é—´åœ¨å½“å‰å®¢æˆ·å¤„ç†ç»“æŸä¹‹å‰
        {
            EnQueue(&BankQueue,temp);  //æš‚å­˜å˜é‡ä¸­çš„å®¢æˆ·ä¿¡æ¯è¿›é˜Ÿ
            have=fscanf(fp,"%d%d",&temp.arrive,&temp.treat);
        }
        clock=finish;  //æ—¶é’Ÿæ¨è¿›åˆ°å½“å‰å®¢æˆ·åŠç†ç»“æŸæ—¶é—´
    }while(have==2||BankQueue.front->next!=NULL);
    printf("ç»“æœï¼šä¸šåŠ¡å‘˜ç­‰å¾…æ—¶é—´%d\\nå®¢æˆ·å¹³å‡ç­‰å¾…æ—¶é—´%f\\n",dwait,(double)wait/count);
    printf("æ¨¡æ‹Ÿæ€»æ—¶é—´ï¼š%d,\\nå®¢æˆ·äººæ•°ï¼š%d,\\næ€»ç­‰å¾…æ—¶é—´ï¼š%d\\n",clock,count,wait);
    getchar();
}
#include<stdio.h>
#include<stdlib.h>
#include <malloc.h>
#define MAX_FILE_NAME_LENGHT 120
#define OK 1
#define ERROR 0

//å®¢æˆ·çš„ä¿¡æ¯ç»“æ„
typedef struct{
    int arrive;
    int treat;
}QNODE;

//é˜Ÿåˆ—èŠ‚ç‚¹å®šä¹‰ç»“æ„
typedef struct node{
    QNODE data;
    struct node *next;//é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¿¡æ¯
}LNODE,*QueuePtr;

//é˜Ÿåˆ—-é“¾é˜Ÿåˆ—ç±»å‹
typedef struct{
    QueuePtr  front ; //é˜Ÿå¤´æŒ‡é’ˆ
    QueuePtr  rear ; //é˜Ÿå°¾æŒ‡é’ˆ
}LinkQueue;

char file_name[MAX_FILE_NAME_LENGHT];
FILE *fp;

/*
 * å‡½æ•°åŠŸèƒ½ï¼šé˜Ÿåˆ—åˆå§‹åŒ–
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 */
int InitQueue(LinkQueue *Q){
    QueuePtr p =(QueuePtr)malloc(sizeof(LNODE));
    if (p == NULL){
        printf("åˆå§‹åŒ–å¤±è´¥\\n");
        return ERROR;
    }
    Q->rear = Q->front = p;
    Q->front->next = NULL;
    return OK;
}
/*
 * å‡½æ•°åŠŸèƒ½ï¼šå…¥é˜Ÿ
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ å…¥é˜Ÿæ•°æ®
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 * */
int EnQueue(LinkQueue* Q,QNODE data){
    QueuePtr p =(QueuePtr)malloc(sizeof(LNODE));
    p->data = data;
    p->next = NULL;
    Q->rear->next = p;
    Q->rear = p;
    return OK;
}
/* å‡½æ•°åŠŸèƒ½ï¼šå‡ºé˜Ÿ
 * ä¼ å…¥å‚æ•°ï¼šé˜Ÿåˆ—æŒ‡é’ˆ å–å€¼å˜é‡æŒ‡é’ˆ
 * ä¼ å…¥å‚æ•°ï¼šæ— 
 * è¿”å›å€¼ï¼šint 1 OK æ“ä½œæˆåŠŸ
 *       int 1 ERROE æ“ä½œå¤±è´¥
 * */
int DeQueue(LinkQueue *Q,QNODE *e){
    if (Q->front == Q->rear) {
        printf("é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ é™¤å¤±è´¥\\n");
        return ERROR;
    }
    LNODE* p;
    p = Q->front->next;
    *e = p->data;
    Q->front->next = p->next;
    if (Q->rear == p)Q->rear = Q->front;
    free(p);
    return OK;
}
/*
 *å‡½æ•°åŠŸèƒ½ï¼šæ¨¡ä»¿æ¨¡æ‹ŸæœåŠ¡å°å‰çš„æ’é˜Ÿç°è±¡é—®é¢˜
 * */
void main(){
    QNODE curret,temp;
    int dwait=0,clock=0,wait=0,count=0,have=0,finish;
    LinkQueue BankQueue;
    InitQueue(&BankQueue);
    printf("\\nè¯·è¾“å…¥è¯»å–æ–‡ä»¶çš„æ–‡ä»¶å\\n");
    scanf("%s",file_name);
    fopen_s(&fp,file_name,"r");
    while (fp == NULL){
        printf("å½“å‰ç›®å½•æ²¡æœ‰æ­¤æ–‡ä»¶ï¼Œè¯·é‡æ–°è¾“å…¥æ–‡ä»¶å");
        scanf("%s",file_name);
    }
    have = fscanf_s(fp,"%d %d",&temp.arrive,&temp.treat);
    do{        //çº¦å®šæ¯è½®å¾ªç¯ï¼Œå¤„ç†ä¸€ä¸ªå®¢æˆ·
        if(BankQueue.front->next == NULL&&have==2)     //ç­‰å¾…é˜Ÿåˆ—ä¸ºç©ºï¼Œä½†è¿˜æœ‰å®¢æˆ·
        {
            dwait+=temp.arrive-clock;  //ç´¯è®¡ä¸šåŠ¡å‘˜æ€»ç­‰å¾…æ—¶é—´
            clock=temp.arrive;
            EnQueue(&BankQueue,temp); //æš‚å­˜å˜é‡ä¸­å®¢æˆ·çš„ä¿¡æ¯è¿›é˜Ÿ
            have=fscanf(fp,"%d %d",&temp.arrive,&temp.treat);
        }
        count++;
        DeQueue(&BankQueue,&curret); //å‡ºé˜Ÿä¸€ä½å®¢æˆ·ä¿¡æ¯
        wait+=clock-curret.arrive;  //ç´¯è®¡åˆ°å®¢æˆ·çš„ç­‰å¾…æ—¶é—´
        finish=clock+curret.treat;  //è®¾å®šä¸šåŠ¡åŠç†ç»“æŸæ—¶é—´
        while(have==2&&temp.arrive<=finish)   //ä¸‹ä¸€ä½å®¢æˆ·åˆ°è¾¾æ—¶é—´åœ¨å½“å‰å®¢æˆ·å¤„ç†ç»“æŸä¹‹å‰
        {
            EnQueue(&BankQueue,temp);  //æš‚å­˜å˜é‡ä¸­çš„å®¢æˆ·ä¿¡æ¯è¿›é˜Ÿ
            have=fscanf(fp,"%d%d",&temp.arrive,&temp.treat);
        }
        clock=finish;  //æ—¶é’Ÿæ¨è¿›åˆ°å½“å‰å®¢æˆ·åŠç†ç»“æŸæ—¶é—´
    }while(have==2||BankQueue.front->next!=NULL);
    printf("ç»“æœï¼šä¸šåŠ¡å‘˜ç­‰å¾…æ—¶é—´%d\\nå®¢æˆ·å¹³å‡ç­‰å¾…æ—¶é—´%f\\n",dwait,(double)wait/count);
    printf("æ¨¡æ‹Ÿæ€»æ—¶é—´ï¼š%d,\\nå®¢æˆ·äººæ•°ï¼š%d,\\næ€»ç­‰å¾…æ—¶é—´ï¼š%d\\n",clock,count,wait);
    getchar();
}
```

## å››ã€å®éªŒä»»åŠ¡

è®¤çœŸé˜…è¯»ä¸ç†è§£å®éªŒå†…å®¹çš„å…·ä½“è¦æ±‚ï¼Œå‚è€ƒæ•™æç›¸å…³ç« èŠ‚ï¼Œç»“åˆå®éªŒå†…å®¹çš„è¦æ±‚ï¼Œç¼–å†™å®éªŒç¨‹åºå¹¶ä¸Šæœºè°ƒè¯•ä¸æµ‹è¯•ï¼Œå®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

## **äº”ã€æ³¨æ„ç‚¹**

1. **fopen()å‡½æ•°åŸå‹ä¸ºFILE \* =fopen(char\* *,char ** );**
2. **fopen_så‡½æ•°æ›´æ”¹ä¸ºint fopen_s(FILE *,char *,char \*);**
3. fscanf_så‡½æ•°åŸå‹ä¸º int fscanf_s(FILE *,char * *,dataType* *......)
4. fscanf_så‡½æ•°åŸå‹ä¸º int fscanf_s(FILE *,char * *,dataType* *......)
5. è¢«æ‰“å¼€çš„æ–‡ä»¶**å¿…é¡»ä¸exeæ–‡ä»¶å¤¹æ”¾åœ¨ä¸€èµ·ï¼Œæˆ–è€…æŒ‡å®šç»å¯¹è·¯å¾„**
6. åœ¨ä½¿ç”¨fscanfå‰ç¡®ä¿ä¼ å…¥çš„FILE*ä¸æ˜¯NULL,å¦åˆ™ä¼šå‡ºç°é”™è¯¯

```c
/*æ–‡ä»¶æ“ä½œå®ä¾‹*/
#include <stdio.h>

int main() {
    char file_name[150] ="text.txt";
    int data;
    int data2;
    FILE *fp;
    int l =1;
    fopen_s(&fp,file_name,"r");
    if (fp != NULL){
        printf("OK");
        fscanf_s(fp,"%d %d",&data2,&data);
        printf("%d %d",data,data2);
    } else{
        printf("Fause");
    }

}
```

## **å®éªŒäº”ã€äºŒå‰æ ‘æ“ä½œåŠåº”ç”¨**

## **ä¸€ã€** **å®éªŒç›®çš„**

æŒæ¡äºŒå‰æ ‘çš„å®šä¹‰ã€ç»“æ„ç‰¹å¾ï¼Œä»¥åŠå„ç§å­˜å‚¨ç»“æ„çš„ç‰¹ç‚¹åŠä½¿ç”¨èŒƒå›´ï¼Œå„ç§éå†ç®—æ³•ã€‚æŒæ¡ç”¨æŒ‡é’ˆç±»å‹æè¿°ã€è®¿é—®å’Œå¤„ç†äºŒå‰æ ‘çš„è¿ç®—ã€‚æŒæ¡å‰åºæˆ–ä¸­åºçš„éé€’å½’éå†ç®—æ³•ã€‚

## äºŒã€ç›¸å…³çŸ¥è¯†

### éå†

äºŒå‰æ ‘çš„éå†ä¸»è¦æœ‰ä¸‰ç§ï¼š

ï¼ˆ1ï¼‰å…ˆ(æ ¹)åºéå†ï¼ˆæ ¹å·¦å³ï¼‰

ï¼ˆ2ï¼‰ä¸­(æ ¹)åºéå†ï¼ˆå·¦æ ¹å³ï¼‰

ï¼ˆ3ï¼‰å(æ ¹)åºéå†ï¼ˆå·¦å³æ ¹ï¼‰

ä¸¾ä¸ªä¾‹å­ï¼š

https://img-blog.csdn.net/20180704200305280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODQwMTI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70

å…ˆ(æ ¹)åºéå†ï¼ˆæ ¹å·¦å³ï¼‰ï¼šA B D H E I C F J K G

ä¸­(æ ¹)åºéå†ï¼ˆå·¦æ ¹å³ï¼‰ : D H B E I A J F K C G

å(æ ¹)åºéå†ï¼ˆå·¦å³æ ¹ï¼‰ : H D I E B J K F G C A

```c
class Node:
    def __init__(self, dat, left=None, right=None):
        self.data = dat
        self.left = left
        self.right = right
 
 
def rebuild(rear, center):
    if not rear:
        return
    cur = Node(rear[-1])
    index = center.index(rear[-1])
    cur.left = rebuild(rear[:index], center[:index])
    cur.right = rebuild(rear[index:-1], center[index + 1:]) #rear[index:-1]æ˜¯åˆ°å€’æ•°ç¬¬äºŒä¸ªæ•°
    return cur
 
 
def pre_order(t):
    if t == None:
        return
    print(t.data)
    pre_order(t.left)
    pre_order(t.right)
 
 
if __name__ == "__main__":
    rear = ['d','a','b','e','c']
    center = ['d','e','b','a','c']
    t = rebuild(rear, center)
    pre_order(t)
```

## **äºŒã€** **å®éªŒè¦æ±‚**

æœ‰å¦‚ä¸‹äºŒå‰æ ‘ï¼š

![äºŒå‰æ ‘](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072700.png)

ç¨‹åºä»£ç ç»™å‡ºäº†è¯¥äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æ„çš„å»ºç«‹ã€å‰åºã€ä¸­åºã€ååºéå†çš„ç®—æ³•ï¼ŒåŒæ—¶ä¹Ÿç»™å‡ºäº†æŸ¥è¯¢â€œEâ€æ˜¯å¦åœ¨äºŒå‰æ ‘é‡Œçš„ä»£ç ã€‚ä»£ç æœ‰ä¸‰å¤„é”™è¯¯ï¼Œæœ‰æ ‡è¯†ï¼Œå±äºé€»è¾‘é”™è¯¯ï¼Œå¯¹ç…§ä¹¦ä¸­çš„ä»£ç ä»”ç»†åˆ†æåï¼Œè¯·ä¿®æ”¹äº†åœ¨ç”µè„‘é‡Œè¿è¡Œã€‚

```c
#include <stdlib.h>
#include <stdio.h>

typedef char DataType;

typedef struct Node

{

DataType data;/*æ•°æ®åŸŸ*/

struct Node *leftChild;/*å·¦å­æ ‘æŒ‡é’ˆ*/

struct Node *rightChild;/*å³å­æ ‘æŒ‡é’ˆ*/

}BiTreeNode;/*ç»“ç‚¹çš„ç»“æ„ä½“å®šä¹‰*/

/*åˆå§‹åŒ–åˆ›å»ºäºŒå‰æ ‘çš„å¤´ç»“ç‚¹*/

void Initiate(BiTreeNode **root)

{

- root = (BiTreeNode *)malloc(sizeof(BiTreeNode));

(*root)->leftChild = NULL;

(*root)->rightChild = NULL;

}

void Destroy(BiTreeNode **root)

{

if((*root) != NULL && (*root)->leftChild != NULL)

Destroy(&(*root)->leftChild);

if((*root) != NULL && (*root)->rightChild != NULL)

Destroy(&(*root)->rightChild);

free(*root);

}

/*è‹¥å½“å‰ç»“ç‚¹curréç©ºï¼Œåœ¨currçš„å·¦å­æ ‘æ’å…¥å…ƒç´ å€¼ä¸ºxçš„æ–°ç»“ç‚¹*/

/*åŸcurræ‰€æŒ‡ç»“ç‚¹çš„å·¦å­æ ‘æˆä¸ºæ–°æ’å…¥ç»“ç‚¹çš„å·¦å­æ ‘*/

/*è‹¥æ’å…¥æˆåŠŸè¿”å›æ–°æ’å…¥ç»“ç‚¹çš„æŒ‡é’ˆï¼Œå¦åˆ™è¿”å›ç©ºæŒ‡é’ˆ*/

BiTreeNode *InsertLeftNode(BiTreeNode *curr, DataType x)

{

BiTreeNode *s, *t;

if(curr == NULL) return NULL;

t = curr->leftChild;/*ä¿å­˜åŸcurræ‰€æŒ‡ç»“ç‚¹çš„å·¦å­æ ‘æŒ‡é’ˆ*/

s = (BiTreeNode *)malloc(sizeof(BiTreeNode));

s->data = x;

s->leftChild = t;/*æ–°æ’å…¥ç»“ç‚¹çš„å·¦å­æ ‘ä¸ºåŸcurrçš„å·¦å­æ ‘*/

s->rightChild = NULL;

curr->leftChild = s;/*æ–°ç»“ç‚¹æˆä¸ºcurrçš„å·¦å­æ ‘*/

return curr->leftChild;/*è¿”å›æ–°æ’å…¥ç»“ç‚¹çš„æŒ‡é’ˆ*/

}

/*è‹¥å½“å‰ç»“ç‚¹curréç©ºï¼Œåœ¨currçš„å³å­æ ‘æ’å…¥å…ƒç´ å€¼ä¸ºxçš„æ–°ç»“ç‚¹*/

/*åŸcurræ‰€æŒ‡ç»“ç‚¹çš„å³å­æ ‘æˆä¸ºæ–°æ’å…¥ç»“ç‚¹çš„å³å­æ ‘*/

/*è‹¥æ’å…¥æˆåŠŸè¿”å›æ–°æ’å…¥ç»“ç‚¹çš„æŒ‡é’ˆï¼Œå¦åˆ™è¿”å›ç©ºæŒ‡é’ˆ*/

BiTreeNode *InsertRightNode(BiTreeNode *curr, DataType x)

{

BiTreeNode *s, *t;

if(curr == NULL) return NULL;

t = curr->rightChild;/*ä¿å­˜åŸcurræ‰€æŒ‡ç»“ç‚¹çš„å³å­æ ‘æŒ‡é’ˆ*/

s = (BiTreeNode *)malloc(sizeof(BiTreeNode));

s->data = x;

s->rightChild = t;/*æ–°æ’å…¥ç»“ç‚¹çš„å³å­æ ‘ä¸ºåŸcurrçš„å³å­æ ‘*/

s->leftChild = NULL;

curr->rightChild = s;/*æ–°ç»“ç‚¹æˆä¸ºcurrçš„å³å­æ ‘*/

return curr->rightChild;/*è¿”å›æ–°æ’å…¥ç»“ç‚¹çš„æŒ‡é’ˆ*/

}

void PreOrder(BiTreeNode *t, void visit(DataType item))

//ä½¿ç”¨visit(item)å‡½æ•°å‰åºéå†äºŒå‰æ ‘t

{

if(t != NULL)

{//æ­¤å°æ®µæœ‰ä¸€å¤„é”™è¯¯

visit(t->data);

PreOrder(t-> rightChild, visit);

PreOrder(t-> leftChild, visit);

}

}

void InOrder(BiTreeNode *t, void visit(DataType item))

//ä½¿ç”¨visit(item)å‡½æ•°ä¸­åºéå†äºŒå‰æ ‘t

{

if(t != NULL)

{//æ­¤å°æ®µæœ‰ä¸€å¤„é”™è¯¯

InOrder(t->leftChild, visit);

InOrder(t->rightChild, visit);

visit(t->data);

}

}

void PostOrder(BiTreeNode *t, void visit(DataType item))

//ä½¿ç”¨visit(item)å‡½æ•°ååºéå†äºŒå‰æ ‘t

{

if(t != NULL)

{//æ­¤å°æ®µæœ‰ä¸€å¤„é”™è¯¯

visit(t->data);

PostOrder(t->leftChild, visit);

PostOrder(t->rightChild, visit);

}

}

void Visit(DataType item)

{

printf("%c ", item);

}

BiTreeNode *Search(BiTreeNode *root, DataType x)//éœ€æ‰¾å…ƒç´ xæ˜¯å¦åœ¨äºŒå‰æ ‘ä¸­

{

BiTreeNode *find=NULL;

if(root!=NULL)

{

if(root->data==x)

find=root;

else

{

find=Search(root->leftChild,x);

if(find==NULL)

find=Search(root->rightChild,x);

}

}

return find;

}

void main(void)

{

BiTreeNode *root, *p, *pp,*find;

char x='E';

Initiate(&root);

p = InsertLeftNode(root, 'A');

p = InsertLeftNode(p, 'B');

p = InsertLeftNode(p, 'D');

p = InsertRightNode(p, 'G');

p = InsertRightNode(root->leftChild, 'C');

pp = p;

InsertLeftNode(p, 'E');

InsertRightNode(pp, 'F');

printf("å‰åºéå†ï¼š");

PreOrder(root->leftChild, Visit);

printf("\\nä¸­åºéå†ï¼š");

InOrder(root->leftChild, Visit);

printf("\\nååºéå†ï¼š");

PostOrder(root->leftChild, Visit);

find=Search(root,x);

if(find!=NULL)

printf("\\næ•°æ®å…ƒç´ %cåœ¨äºŒå‰æ ‘ä¸­ \\n",x);

else

printf("\\næ•°æ®å…ƒç´ %cä¸åœ¨äºŒå‰æ ‘ä¸­ \\n",x);

Destroy(&root);

}
```

## **ä¸‰ã€** **å®éªŒä»»åŠ¡ï¼š**

1.æ”¹æ­£ç¨‹åºé”™è¯¯ã€‚

2.ç¼–å†™äºŒå‰æ ‘çš„å‰åºï¼ˆæˆ–ä¸­åºï¼‰çš„éé€’å½’éå†ç®—æ³•å¹¶è¿›è¡Œæµ‹è¯•ã€‚

![image-20210321072712755](https://gitee.com/tanzicai/drawingbed/raw/master/img/20210321072712.png)

\#include<stack>

using namespace std;

stack<BiTreeNode*> s;

BiTreeNode *p;

s.push(p);

s.top();

s.pop();

s.empty()_

3.å®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

## **å®éªŒå…­ã€å›¾çš„éå†æ“ä½œåŠåº”ç”¨**

- ***ä¸€\*ã€\*å®éªŒç›®çš„\****

æŒæ¡æœ‰å‘å›¾å’Œæ— å‘å›¾çš„æ¦‚å¿µï¼›æŒæ¡é‚»æ¥çŸ©é˜µå’Œé‚»æ¥é“¾è¡¨å»ºç«‹å›¾çš„å­˜å‚¨ç»“æ„ï¼›æŒæ¡DFSåŠBFSå¯¹å›¾çš„éå†æ“ä½œï¼›äº†è§£å›¾ç»“æ„åœ¨äººå·¥æ™ºèƒ½ã€å·¥ç¨‹ç­‰é¢†åŸŸçš„å¹¿æ³›åº”ç”¨ã€‚

**äºŒã€** ***å®éªŒè¦æ±‚\****

é‡‡ç”¨é‚»æ¥çŸ©é˜µå’Œé‚»æ¥é“¾è¡¨ä½œä¸ºå›¾çš„å­˜å‚¨ç»“æ„ï¼Œå®Œæˆæœ‰å‘å›¾å’Œæ— å‘å›¾çš„DFSå’ŒBFSæ“ä½œã€‚æœ¬å®éªŒç»™å‡ºäº†ç¤ºä¾‹ç¨‹åºï¼Œå…¶ä¸­å…±æœ‰4å¤„é”™è¯¯ï¼Œé”™è¯¯æ®µå‡æœ‰æ ‡è¯†ï¼Œå±äºé€»è¾‘é”™è¯¯ã€‚è¯·è®¤çœŸç†è§£ç¨‹åºï¼Œä¿®æ”¹ç¨‹åºä»£ç ï¼Œå¹¶åœ¨ç”µè„‘ä¸Šè°ƒè¯•è¿è¡Œã€‚

**ä¸‰ã€** ***DFSå’ŒBFS çš„åŸºæœ¬æ€æƒ³\****

- ***æ·±åº¦ä¼˜å…ˆæœç´¢æ³•DFSçš„åŸºæœ¬æ€æƒ³ï¼š****ä»å›¾Gä¸­æŸä¸ªé¡¶ç‚¹Voå‡ºå‘ï¼Œé¦–å…ˆè®¿é—®Voï¼Œç„¶åé€‰æ‹©ä¸€ä¸ªä¸Voç›¸é‚»ä¸”æ²¡è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹Viè®¿é—®ï¼Œå†ä»Viå‡ºå‘é€‰æ‹©ä¸€ä¸ªä¸Viç›¸é‚»ä¸”æ²¡è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹Vjè®¿é—®ï¼Œâ€¦â€¦ä¾æ¬¡ç»§ç»­ã€‚å¦‚æœå½“å‰è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹éƒ½å·²è¢«è®¿é—®ï¼Œåˆ™å›é€€åˆ°å·²è¢«è®¿é—®çš„é¡¶ç‚¹åºåˆ—ä¸­æœ€åä¸€ä¸ªæ‹¥æœ‰æœªè¢«è®¿é—®çš„ç›¸é‚»é¡¶ç‚¹çš„é¡¶ç‚¹Wï¼Œä»Wå‡ºå‘æŒ‰åŒæ ·æ–¹æ³•å‘å‰éå†ã€‚ç›´åˆ°å›¾ä¸­æ‰€æœ‰çš„é¡¶ç‚¹éƒ½è¢«è®¿é—®ã€‚
- ***å¹¿åº¦ä¼˜å…ˆç®—æ³•BFSçš„åŸºæœ¬æ€æƒ³ï¼š****ä»å›¾Gä¸­æŸä¸ªé¡¶ç‚¹Voå‡ºå‘ï¼Œé¦–å…ˆè®¿é—®Voï¼Œç„¶åè®¿é—®ä¸Voç›¸é‚»çš„æ‰€æœ‰æœªè¢«è®¿é—®è¿‡çš„é¡¶ç‚¹V1ï¼ŒV2ï¼Œâ€¦â€¦ï¼ŒVtï¼›å†ä¾æ¬¡è®¿é—®ä¸V1ï¼ŒV2ï¼Œâ€¦â€¦ï¼ŒVtç›¸é‚»çš„èµ·ä¸”æœªè¢«è®¿é—®è¿‡çš„çš„æ‰€æœ‰é¡¶ç‚¹ã€‚å¦‚æ­¤ç»§ç»­ï¼Œç›´åˆ°è®¿é—®å®Œå›¾ä¸­çš„æ‰€æœ‰é¡¶ç‚¹ã€‚

![file:////private/var/folders/rq/rhtpqfks4_3brk7ddz_g1qh80000gn/T/com.kingsoft.wpsoffice.mac/wps-tanzicai/ksohtml/wpsF7cE0U.png?lastModify=1605522401](private/var/folders/rq/rhtpqfks4_3brk7ddz_g1qh80000gn/T/com.kingsoft.wpsoffice.mac/wps-tanzicai/ksohtml/wpsF7cE0U.png?lastModify=1605522401)

å››ã€

- ç¤ºä¾‹ç¨‹åº
- 1.é‚»æ¥çŸ©é˜µä½œä¸ºå­˜å‚¨ç»“æ„çš„ç¨‹åºç¤ºä¾‹

```c
#include"stdio.h"

\#include"stdlib.h"

\#define MaxVertexNum 100 //å®šä¹‰æœ€å¤§é¡¶ç‚¹æ•°

typedef struct{

char vexs[MaxVertexNum]; //é¡¶ç‚¹è¡¨

int edges**[MaxVertexNum](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**; //é‚»æ¥çŸ©é˜µï¼Œå¯çœ‹ä½œè¾¹è¡¨

int n,e; //å›¾ä¸­çš„é¡¶ç‚¹æ•°nå’Œè¾¹æ•°e

}MGraph; //ç”¨é‚»æ¥çŸ©é˜µè¡¨ç¤ºçš„å›¾çš„ç±»å‹

//=========å»ºç«‹é‚»æ¥çŸ©é˜µ=======

void CreatMGraph(MGraph *G)

{

int i,j,k;

char a;

printf("Input VertexNum(n) and EdgesNum(e): ");

scanf("%d,%d",&G->n,&G->e); //è¾“å…¥é¡¶ç‚¹æ•°å’Œè¾¹æ•°

scanf("%c",&a);

printf("Input Vertex string:");

for(i=0;i<G->n;i++)

{

scanf("%c",&a);

G->vexs[i]=a; //è¯»å…¥é¡¶ç‚¹ä¿¡æ¯ï¼Œå»ºç«‹é¡¶ç‚¹è¡¨

}

for(i=0;i<G->n;i++)

for(j=0;j<G->n;j++)

G->edges**[i](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**=0; //åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ

printf("Input edges,Creat Adjacency Matrix\n");

for(k=0;k<G->e;k++) { //è¯»å…¥eæ¡è¾¹ï¼Œå»ºç«‹é‚»æ¥çŸ©é˜µ

scanf("%d%d",&i,&j); //è¾“å…¥è¾¹ï¼ˆViï¼ŒVjï¼‰çš„é¡¶ç‚¹åºå·

G->edges**[i](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**=1;

G->edges**[j](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**=1; //è‹¥ä¸ºæ— å‘å›¾ï¼ŒçŸ©é˜µä¸ºå¯¹ç§°çŸ©é˜µï¼›è‹¥å»ºç«‹æœ‰å‘å›¾ï¼Œå»æ‰è¯¥æ¡è¯­å¥

}

}

//=========å®šä¹‰æ ‡å¿—å‘é‡ï¼Œä¸ºå…¨å±€å˜é‡=======

typedef enum{FALSE,TRUE} Boolean;

Boolean visited[MaxVertexNum];

//========DFSï¼šæ·±åº¦ä¼˜å…ˆéå†çš„é€’å½’ç®—æ³•======

void DFSM(MGraph *G,int i)

{ //ä»¥Viä¸ºå‡ºå‘ç‚¹å¯¹é‚»æ¥çŸ©é˜µè¡¨ç¤ºçš„å›¾Gè¿›è¡ŒDFSæœç´¢ï¼Œé‚»æ¥çŸ©é˜µæ˜¯0ï¼Œ1çŸ©é˜µ

int j;

printf("%c",G->vexs[i]); //è®¿é—®é¡¶ç‚¹Vi

visited[i]=TRUE; //ç½®å·²è®¿é—®æ ‡å¿—

for(j=0;j<G->n;j++) //ä¾æ¬¡æœç´¢Viçš„é‚»æ¥ç‚¹

if(G->edges**[i](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**==1 && ! visited[j])

DFSM(G,j); //ï¼ˆViï¼ŒVjï¼‰âˆˆEï¼Œä¸”Vjæœªè®¿é—®è¿‡ï¼Œæ•…Vjä¸ºæ–°å‡ºå‘ç‚¹

}

void DFS(MGraph *G)

{ //æ­¤æ®µä»£ç æœ‰ä¸€å¤„é”™è¯¯

int i;

for(i=0;i<G->n;i++)

visited[i]=FALSE; //æ ‡å¿—å‘é‡åˆå§‹åŒ–

for(i=0;i<G->n;i++)

if(!visited[i]) //Viæœªè®¿é—®è¿‡

DFS(G,i); //ä»¥Viä¸ºæºç‚¹å¼€å§‹DFSæœç´¢

}

//===========BFSï¼šå¹¿åº¦ä¼˜å…ˆéå†=======

void BFS(MGraph *G,int k)

{ //ä»¥Vkä¸ºæºç‚¹å¯¹ç”¨é‚»æ¥çŸ©é˜µè¡¨ç¤ºçš„å›¾Gè¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢

int i,j,f=0,r=0;

int cq[MaxVertexNum]; //å®šä¹‰é˜Ÿåˆ—

for(i=0;i<G->n;i++)

visited[i]=FALSE; //æ ‡å¿—å‘é‡åˆå§‹åŒ–

for(i=0;i<=G->n;i++)

cq[i]=-1; //é˜Ÿåˆ—åˆå§‹åŒ–

printf("%c",G->vexs[k]); //è®¿é—®æºç‚¹Vk

visited[k]=TRUE;

cq[r]=k; //Vkå·²è®¿é—®ï¼Œå°†å…¶å…¥é˜Ÿã€‚æ³¨æ„ï¼Œå®é™…ä¸Šæ˜¯å°†å…¶åºå·å…¥é˜Ÿ

while(cq[f]!=-1) { //é˜Ÿéç©ºåˆ™æ‰§è¡Œ

i=cq[f]; f=f+1; //Vfå‡ºé˜Ÿ

for(j=0;j<G->n;j++) //ä¾æ¬¡Viçš„é‚»æ¥ç‚¹Vj

if(G->edges**[i](notion://www.notion.so/afc75248d48d4c3baadfce4b9c10a03d#)**==1 && !visited[j]) { //Vjæœªè®¿é—® ä»¥ä¸‹ä¸‰è¡Œä»£ç æœ‰ä¸€å¤„é”™è¯¯

printf("%c",G->vexs[j]); //è®¿é—®Vj

visited[j]=FALSE; r=r+1; cq[r]=j; //è®¿é—®è¿‡Vjå…¥é˜Ÿ

}

}

}

//==========main=====

void main()

{

MGraph *G;

G=(MGraph *)malloc(sizeof(MGraph)); //ä¸ºå›¾Gç”³è¯·å†…å­˜ç©ºé—´

CreatMGraph(G); //å»ºç«‹é‚»æ¥çŸ©é˜µ

printf("Print Graph DFS: ");

DFS(G); //æ·±åº¦ä¼˜å…ˆéå†

printf("\n");

printf("Print Graph BFS: ");

BFS(G,3); //ä»¥åºå·ä¸º3çš„é¡¶ç‚¹å¼€å§‹å¹¿åº¦ä¼˜å…ˆéå†

printf("\n");}
```



- ***æ‰§è¡Œé¡ºåºï¼š\****

```Input VertexNum(n) and EdgesNum(e): 8ï¼Œ9
Input Vertex string: 01234567

Input edges,Creat Adjacency Matrix

0 1

0 2

1 3

1 4

2 5

2 6

3 7

4 7

5 6

Print Graph DFS: 01374256

Print Graph BFS: 31704256
```

- ***2.\*é‚»æ¥é“¾è¡¨ä½œä¸ºå­˜å‚¨ç»“æ„ç¨‹åºç¤ºä¾‹\****

```c
\#include"stdio.h"

\#include"stdlib.h"

\#define MaxVertexNum 50 //å®šä¹‰æœ€å¤§é¡¶ç‚¹æ•°

typedef struct node{ //è¾¹è¡¨ç»“ç‚¹

int adjvex; //é‚»æ¥ç‚¹åŸŸ

struct node *next; //é“¾åŸŸ

}EdgeNode;

typedef struct vnode{ //é¡¶ç‚¹è¡¨ç»“ç‚¹

char vertex; //é¡¶ç‚¹åŸŸ

EdgeNode *firstedge; //è¾¹è¡¨å¤´æŒ‡é’ˆ

}VertexNode;

typedef VertexNode AdjList[MaxVertexNum]; //AdjListæ˜¯é‚»æ¥è¡¨ç±»å‹

typedef struct {

AdjList adjlist; //é‚»æ¥è¡¨

int n,e; //å›¾ä¸­å½“å‰é¡¶ç‚¹æ•°å’Œè¾¹æ•°

} ALGraph; //å›¾ç±»å‹

//=========å»ºç«‹å›¾çš„é‚»æ¥è¡¨=======

void CreatALGraph(ALGraph *G)

{

int i,j,k;

char a;

EdgeNode *s; //å®šä¹‰è¾¹è¡¨ç»“ç‚¹

printf("Input VertexNum(n) and EdgesNum(e): ");

scanf("%d,%d",&G->n,&G->e); //è¯»å…¥é¡¶ç‚¹æ•°å’Œè¾¹æ•°

scanf("%c",&a);

printf("Input Vertex string:");

for(i=0;i<G->n;i++) //å»ºç«‹é¡¶ç‚¹è¡¨

{

scanf("%c",&a);

G->adjlist[i].vertex=a; //è¯»å…¥é¡¶ç‚¹ä¿¡æ¯

G->adjlist[i].firstedge=NULL; //è¾¹è¡¨ç½®ä¸ºç©ºè¡¨

}

printf("Input edges,Creat Adjacency List\n");

for(k=0;k<G->e;k++) { //å»ºç«‹è¾¹è¡¨

scanf("%d%d",&i,&j); //è¯»å…¥è¾¹ï¼ˆViï¼ŒVjï¼‰çš„é¡¶ç‚¹å¯¹åºå·

s=(EdgeNode *)malloc(sizeof(EdgeNode)); //ç”Ÿæˆè¾¹è¡¨ç»“ç‚¹

s->adjvex=j; //é‚»æ¥ç‚¹åºå·ä¸ºj

s->next=G->adjlist[i].firstedge;

G->adjlist[i].firstedge=s; //å°†æ–°ç»“ç‚¹*Sæ’å…¥é¡¶ç‚¹Viçš„è¾¹è¡¨å¤´éƒ¨

s=(EdgeNode *)malloc(sizeof(EdgeNode));

s->adjvex=i; //é‚»æ¥ç‚¹åºå·ä¸ºi

s->next=G->adjlist[j].firstedge;

G->adjlist[j].firstedge=s; //å°†æ–°ç»“ç‚¹*Sæ’å…¥é¡¶ç‚¹Vjçš„è¾¹è¡¨å¤´éƒ¨

}

}

//=========å®šä¹‰æ ‡å¿—å‘é‡ï¼Œä¸ºå…¨å±€å˜é‡=======

typedef enum{FALSE,TRUE} Boolean;

Boolean visited[MaxVertexNum];

//========DFSï¼šæ·±åº¦ä¼˜å…ˆéå†çš„é€’å½’ç®—æ³•======

void DFSM(ALGraph *G,int i)

{ //ä»¥Viä¸ºå‡ºå‘ç‚¹å¯¹é‚»æ¥é“¾è¡¨è¡¨ç¤ºçš„å›¾Gè¿›è¡ŒDFSæœç´¢

EdgeNode *p;

printf("%c",G->adjlist[i].vertex); //è®¿é—®é¡¶ç‚¹Vi

visited[i]=TRUE; //æ ‡è®°Viå·²è®¿é—®

p=G->adjlist[i].firstedge; //å–Viè¾¹è¡¨çš„å¤´æŒ‡é’ˆ

while(p) { //ä¾æ¬¡æœç´¢Viçš„é‚»æ¥ç‚¹Vjï¼Œè¿™é‡Œj=p->adjvex

//ä»¥ä¸‹3è¡Œä»£ç æœ‰ä¸€å¤„é”™è¯¯

if(! visited[p->adjvex]) //è‹¥Vjå°šæœªè¢«è®¿é—®

DFS(G,p->adjvex); //åˆ™ä»¥Vjä¸ºå‡ºå‘ç‚¹å‘çºµæ·±æœç´¢

p=p->next; //æ‰¾Viçš„ä¸‹ä¸€ä¸ªé‚»æ¥ç‚¹

}

}

void DFS(ALGraph *G)

{

int i;

for(i=0;i<G->n;i++)

visited[i]=FALSE; //æ ‡å¿—å‘é‡åˆå§‹åŒ–

for(i=0;i<G->n;i++)

if(!visited[i]) //Viæœªè®¿é—®è¿‡

DFSM(G,i); //ä»¥Viä¸ºæºç‚¹å¼€å§‹DFSæœç´¢

}

//==========BFSï¼šå¹¿åº¦ä¼˜å…ˆéå†=========

void BFS(ALGraph *G,int k)

{ //ä»¥Vkä¸ºæºç‚¹å¯¹ç”¨é‚»æ¥é“¾è¡¨è¡¨ç¤ºçš„å›¾Gè¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢

int i,f=0,r=0;

EdgeNode *p;

int cq[MaxVertexNum]; //å®šä¹‰FIFOé˜Ÿåˆ—

for(i=0;i<G->n;i++)

visited[i]=FALSE; //æ ‡å¿—å‘é‡åˆå§‹åŒ–

for(i=0;i<=G->n;i++)

cq[i]=-1; //åˆå§‹åŒ–æ ‡å¿—å‘é‡

printf("%c",G->adjlist[k].vertex); //è®¿é—®æºç‚¹Vk

visited[k]=TRUE;

cq[r]=k; //Vkå·²è®¿é—®ï¼Œå°†å…¶å…¥é˜Ÿã€‚æ³¨æ„ï¼Œå®é™…ä¸Šæ˜¯å°†å…¶åºå·å…¥é˜Ÿ

while(cq[f]!=-1)

{ //é˜Ÿåˆ—éç©ºåˆ™æ‰§è¡Œ

i=cq[f]; f=f+1; //Viå‡ºé˜Ÿ

p=G->adjlist[i].firstedge; //å–Viçš„è¾¹è¡¨å¤´æŒ‡é’ˆ

while(p)

{ //ä¾æ¬¡æœç´¢Viçš„é‚»æ¥ç‚¹Vjï¼ˆä»¤p->adjvex=jï¼‰

if(!visited[p->adjvex]) { //è‹¥Vjæœªè®¿é—®è¿‡

printf("%c",G->adjlist[p->adjvex].vertex); //è®¿é—®Vj

visited[p->adjvex]=TRUE;

//ä»¥ä¸‹3è¡Œä»£ç æœ‰ä¸€å¤„é”™è¯¯

r=r+1; cq[r]=p->adjvex; //è®¿é—®è¿‡çš„Vjå…¥é˜Ÿ

}

p=p->next->next; //æ‰¾Viçš„ä¸‹ä¸€ä¸ªé‚»æ¥ç‚¹

}

}//endwhile

}

//==========ä¸»å‡½æ•°===========

void main()

{

int i;

ALGraph *G;

G=(ALGraph *)malloc(sizeof(ALGraph));

CreatALGraph(G);

printf("Print Graph DFS: ");

DFS(G);

printf("\n");

printf("Print Graph BFS: ");

BFS(G,3);

printf("\n");

}
```



- ***æ‰§è¡Œé¡ºåºï¼š\****

```
Input VertexNum(n) and EdgesNum(e): 8ï¼Œ9

Input Vertex string: 01234567

Input edges,Creat Adjacency List

0 1

0 2

1 3

1 4

2 5

2 6

3 7

4 7

5 6

Print Graph DFS: 02651473

Print Graph BFS: 37140265
```



**äºŒã€** ***å®éªŒä»»åŠ¡\****

\1. æ”¹æ­£ç¨‹åºä¸­çš„é”™è¯¯å¹¶è°ƒè¯•é€šè¿‡ï¼Œæµ‹è¯•å¹¶å®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

\2. é€‰åšé¢˜ï¼Œç¼–å†™ç¨‹åºè¾“å‡ºè¯¥æ— å‘ç½‘ç»œçš„æœ€å°ç”Ÿæˆæ ‘ä»¥åŠè¯¥æœ€å°ç”Ÿæˆæ ‘çš„æ‰€æœ‰è¾¹ã€‚

## å®éªŒä¸ƒã€æŸ¥æ‰¾ç®—æ³•çš„å®ç°

**ä¸€ã€å®éªŒç›®çš„**

æŒæ¡**é¡ºåºå’ŒäºŒåˆ†æŸ¥æ‰¾ç®—æ³•**çš„åŸºæœ¬æ€æƒ³åŠå…¶å®ç°æ–¹æ³•ã€‚

**äºŒã€å®éªŒè¦æ±‚**

é—®é¢˜æè¿°ï¼šå¯¹ç»™å®šçš„ä»»æ„æ•°ç»„ï¼ˆè®¾å…¶é•¿åº¦ä¸ºnï¼‰ï¼Œåˆ†åˆ«ç”¨é¡ºåºå’ŒäºŒåˆ†æŸ¥æ‰¾æ–¹æ³•åœ¨æ­¤æ•°ç»„ä¸­æŸ¥æ‰¾ä¸ç»™å®šå€¼kç›¸ç­‰çš„å…ƒç´ ã€‚

**é¡ºåºæŸ¥æ‰¾åŸºæœ¬æ€æƒ³ï¼š**ä»æŸ¥æ‰¾è¡¨çš„ä¸€ç«¯å¼€å§‹ï¼Œé€ä¸ªå°†è®°å½•çš„å…³é”®å­—å€¼å’Œç»™å®šå€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœæŸä¸ªè®°å½•çš„å…³é”®å­—å€¼å’Œç»™å®šå€¼ç›¸ç­‰ï¼Œåˆ™ç§°æŸ¥æ‰¾æˆåŠŸï¼›å¦åˆ™ï¼Œè¯´æ˜æŸ¥æ‰¾è¡¨ä¸­ä¸å­˜åœ¨å…³é”®å­—å€¼ä¸ºç»™å®šå€¼çš„è®°å½•ï¼Œåˆ™ç§°æŸ¥æ‰¾å¤±è´¥ã€‚

**äºŒåˆ†æŸ¥æ‰¾åŸºæœ¬æ€æƒ³ï¼š**å…ˆå–æŸ¥æ‰¾è¡¨çš„ä¸­é—´ä½ç½®çš„å…³é”®å­—å€¼ä¸ç»™å®šå…³é”®å­—å€¼ä½œæ¯”è¾ƒï¼Œè‹¥å®ƒä»¬çš„å€¼ç›¸ç­‰ï¼Œåˆ™æŸ¥æ‰¾æˆåŠŸï¼›å¦‚æœç»™å®šå€¼æ¯”è¯¥è®°å½•çš„å…³é”®å­—å€¼å¤§ï¼Œè¯´æ˜è¦æŸ¥æ‰¾çš„è®°å½•ä¸€å®šåœ¨æŸ¥æ‰¾è¡¨çš„ååŠéƒ¨åˆ†ï¼Œåˆ™åœ¨æŸ¥æ‰¾è¡¨çš„ååŠéƒ¨åˆ†ç»§ç»­ä½¿ç”¨æŠ˜åŠæŸ¥æ‰¾ï¼›è‹¥ç»™å®šå€¼æ¯”è¯¥è®°å½•çš„å…³é”®å­—å€¼å°ï¼Œè¯´æ˜è¦æŸ¥æ‰¾çš„è®°å½•ä¸€å®šåœ¨æŸ¥æ‰¾è¡¨çš„å‰åŠéƒ¨åˆ†ï¼Œåˆ™åœ¨æŸ¥æ‰¾è¡¨çš„å‰åŠéƒ¨åˆ†ç»§ç»­ä½¿ç”¨æŠ˜åŠæŸ¥æ‰¾ã€‚â€¦ç›´åˆ°æŸ¥æ‰¾æˆåŠŸï¼Œæˆ–è€…ç›´åˆ°ç¡®å®šæŸ¥æ‰¾è¡¨ä¸­æ²¡æœ‰å¾…æŸ¥æ‰¾çš„è®°å½•ä¸ºæ­¢ï¼Œå³æŸ¥æ‰¾å¤±è´¥ã€‚

**ä¸¤è€…æ¯”è¾ƒï¼š**

ï¼ˆ1ï¼‰é¡ºåºæŸ¥æ‰¾çš„æŸ¥æ‰¾æ•ˆç‡å¾ˆä½ï¼›ä½†æ˜¯å¯¹äºå¾…æŸ¥è®°å½•çš„å­˜å‚¨ç»“æ„æ²¡æœ‰ä»»ä½•è¦æ±‚ï¼Œæ—¢é€‚ç”¨äºé¡ºåºå­˜å‚¨ï¼Œåˆé€‚ç”¨äºé“¾å¼å­˜å‚¨ï¼›å½“å¾…æŸ¥è¡¨ä¸­çš„è®°å½•ä¸ªæ•°è¾ƒå°‘æ—¶ï¼Œé‡‡ç”¨é¡ºåºæŸ¥æ‰¾æ³•è¾ƒå¥½ã€‚

ï¼ˆ2ï¼‰äºŒåˆ†æŸ¥æ‰¾çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦è¾ƒå°ï¼ŒæŸ¥æ‰¾é€Ÿåº¦å¿«ï¼›ä½†å®ƒåªèƒ½ç”¨äºé¡ºåºå­˜å‚¨ï¼Œä¸èƒ½ç”¨äºé“¾å¼å­˜å‚¨ï¼›ä¸”è¦æ±‚è¡¨ä¸­çš„è®°å½•æ˜¯æœ‰åºçš„ã€‚å¯¹äºä¸å¸¸å˜åŠ¨çš„æœ‰åºè¡¨ï¼Œé‡‡ç”¨æŠ˜åŠæŸ¥æ‰¾æ³•æ˜¯è¾ƒä¸ºç†æƒ³çš„ã€‚

**ä¸‰ã€ç®—æ³•æ€æƒ³ä¸ç®—æ³•æè¿°**

1ã€é¡ºåºæŸ¥æ‰¾ï¼Œåœ¨é¡ºåºè¡¨R[0..n-1]ä¸­æŸ¥æ‰¾å…³é”®å­—ä¸ºkçš„è®°å½•ï¼ŒæˆåŠŸæ—¶è¿”å›æ‰¾åˆ°çš„è®°å½•ä½ç½®ï¼Œå¤±è´¥æ—¶è¿”å›-1ï¼Œå…·ä½“çš„ç®—æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```c
int SeqSearch(SeqList R[],int n,KeyType k)
{
int i=0;
while(i<n&&R[i].key!=k)
{
printf("%d",R[i].key);
i++;

}
if(i>=n)
return -1;
else
{
printf("%d",R[i].key);
return i;
}
}
```

**ç¨‹åºä»£ç **

```c
#include <stdio.h>
#define KeyType int
#define MAX_SIZE 10
//é¡ºåºè¡¨ç»“æ„ä½“
typedef struct{
    int oder;
    KeyType key;
}SeqList;
//é¡ºåºæŸ¥æ‰¾å‡½æ•°
int SeqSearch(SeqList R[],int n,KeyType k)
{
    int i=0;
    while(i<=n&&R[i].key!=k)
    {
        //printf("%d:%d\\n",i,R[i].key);
        i++;
    }
    if(i > n)
        return -1;
    else
    {
        printf("%dï¼",R[i].key);
        return i;
    }
}

int main() {
		//åˆå§‹åŒ–å¾…æŸ¥æ‰¾æ•°æ®
    SeqList source[]={{0,9},{1,13},{2,15},{3,7},{4,45},{5,32},{6,56},{7,89},{8,60},{9,36}};
    //æŸ¥æ‰¾çš„æ•°æ®
		int finder;
		//è¿”å›çš„ä¸‹æ ‡
    int result=-1;
		//æŸ¥æ‰¾å¼€å§‹
    printf("ç¨‹åºå¼€å§‹***************************\\nè¯·è¾“å…¥æŸ¥æ‰¾å†…å®¹ï¼š");
    scanf("%d",&finder);
		//è¿”å›æŸ¥æ‰¾å†…å®¹ -1ï¼šæœªæ‰¾åˆ° å¦åˆ™è¿”å›ä¸‹æ ‡å¿—
    result= SeqSearch(source,9,finder);
    if (result == -1)printf("æœªæŸ¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯");
    else printf("æ‰€æŸ¥æ‰¾å…ƒç´ ä¸‹æ ‡å€¼ä¸º%d",result);
    return 0;
}
```

2ã€äºŒåˆ†æŸ¥æ‰¾ï¼Œåœ¨æœ‰åºè¡¨R[0..n-1]ä¸­è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼ŒæˆåŠŸæ—¶è¿”å›è®°å½•çš„ä½ç½®ï¼Œå¤±è´¥æ—¶è¿”å›-1ï¼Œå…·ä½“çš„ç®—æ³•å¦‚ä¸‹ï¼š

```c
int BinSearch(SeqList R[],int n,KeyType k)
{
int low=0,high=n-1,mid,count=0;
while(low<=high)
{
mid=(low+high)/2;
printf("ç¬¬%dæ¬¡æŸ¥æ‰¾ï¼šåœ¨[ %d ,%d]ä¸­æ‰¾åˆ°å…ƒç´ R[%d]:%d\\n ",++count,low,high,mid,R[mid].key);
if(R[mid].key==k)
return mid;
if(R[mid].key>k)
high=mid-1;
else
low=mid+1;
}
return -1;
}
#include <stdio.h>
#define KeyType int
#define MAX_SIZE 10
//é¡ºåºè¡¨ç»“æ„ä½“
typedef struct{
    int oder;
    KeyType key;
}SeqList;
int BinSearch(SeqList R[],int n,KeyType k)
{
    int low=0,high=n-1,mid,count=0;
    while(low<=high)
    {
        mid=(low+high)/2;
        printf("ç¬¬%dæ¬¡æŸ¥æ‰¾ï¼šåœ¨[ %d ,%d]ä¸­æ‰¾åˆ°å…ƒç´ R[%d]:%d\\n ",++count,low,high,mid,R[mid].key);
        if(R[mid].key==k)
            return mid;
        if(R[mid].key>k)
            high=mid-1;
        else
            low=mid+1;
    }
    return -1;
}
int main() {
    //åˆå§‹åŒ–å¾…æŸ¥æ‰¾æ•°æ®
    SeqList source[]={{0,5},{1,7},{2,9},{3,12},{4,15},{5,18},{6,20},{7,22},{8,25},{9,30},{10,100}};
    //æŸ¥æ‰¾çš„æ•°æ®
    int finder;
    //è¿”å›çš„ä¸‹æ ‡
    printf("*********************ç¨‹åºå¼€å§‹***************************\\n");
    int result=-1;
    //æŸ¥æ‰¾å¼€å§‹
    printf("è¯·è¾“å…¥æŸ¥æ‰¾å†…å®¹ï¼š");
    scanf("%d",&finder);
    while (finder != '-1'){
        //è¿”å›æŸ¥æ‰¾å†…å®¹ -1ï¼šæœªæ‰¾åˆ° å¦åˆ™è¿”å›ä¸‹æ ‡å¿—
        result= BinSearch(source,10,finder);
        if (result == -1)printf("æœªæŸ¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯\\n");
        else printf("æ‰€æŸ¥æ‰¾å…ƒç´ ä¸‹æ ‡å€¼ä¸º%d\\n",result);
        printf("è¯·è¾“å…¥æŸ¥æ‰¾å†…å®¹ï¼š");
        scanf("%d",&finder);
    }
    return 0;
}
```

### Cæ–¹å¼å®ç°

```java
#include <stdio.h>
#define KeyType int
#define MAX_SIZE 10
//é¡ºåºè¡¨ç»“æ„ä½“
typedef struct{
    int oder;
    KeyType key;
}SeqList;

/*
 * é¡ºåºæŸ¥æ‰¾
 * R[] æ•°ç»„ å¾…æŸ¥æ‰¾æ•°æ®ç»„
 * n int å¾…æŸ¥æ‰¾æ•°æ®é•¿åº¦
 * k KeyTypeæŸ¥æ‰¾æ•°æ®
 * */
int SeqSearch(SeqList R[],int n,KeyType k)
{
    int i=0;
    while(i<=n&&R[i].key!=k)
    {
        //printf("%d:%d\\n",i,R[i].key);
        i++;
    }
    if(i > n)
        return -1;
    else
    {
        printf("%dï¼",R[i].key);
        return i;
    }
}

/*
 * æŠ˜åŠæ–¹æŸ¥æ‰¾
 * R[] æ•°ç»„ å¾…æŸ¥æ‰¾æ•°æ®ç»„
 * n int å¾…æŸ¥æ‰¾æ•°æ®é•¿åº¦
 * k KeyTypeæŸ¥æ‰¾æ•°æ®
 * */
int BinSearch(SeqList R[],int n,KeyType k)
{
    int low=0,high=n-1,mid,count=0;
    while(low<=high)
    {
        mid=(low+high)/2;
        printf("ç¬¬%dæ¬¡æŸ¥æ‰¾ï¼šåœ¨[ %d ,%d]ä¸­æ‰¾åˆ°å…ƒç´ R[%d]:%d\\n ",++count,low,high,mid,R[mid].key);
        if(R[mid].key==k)
            return mid;
        if(R[mid].key>k)
            high=mid-1;
        else
            low=mid+1;
    }
    return -1;
}

/*
 * æ’å€¼æŸ¥æ‰¾
 * R[] æ•°ç»„ å¾…æŸ¥æ‰¾æ•°æ®ç»„
 * n int å¾…æŸ¥æ‰¾æ•°æ®é•¿åº¦
 * k KeyTypeæŸ¥æ‰¾æ•°æ®
 * */
int interpolationSearch(SeqList R[],int n,KeyType k)
{
    int low=0,high=n-1,mid,count=0;
    while (low < high) {
        mid = low + (high - low) * (k - R[low].key) / (R[high].key - R[low].key);
        printf("ç¬¬%dæ¬¡æŸ¥æ‰¾ï¼šåœ¨[ %d ,%d]ä¸­æ‰¾åˆ°å…ƒç´ R[%d]:%d\\n ",++count,low,high,mid,R[mid].key);
        // mid = (high + low) / 2;// æŠ˜åŠä¸‹æ ‡
        if (k > R[mid].key) {
            low = mid + 1; // å…³é”®å­—æ¯” æŠ˜åŠå€¼ å¤§ï¼Œåˆ™æœ€å°ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„ä¸‹ä¸€ä½
        } else if (k < R[mid].key) {
            high = mid - 1;// å…³é”®å­—æ¯” æŠ˜åŠå€¼ å°ï¼Œåˆ™æœ€å¤§ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„å‰ä¸€ä½
        } else {
            return mid; // å½“ key == a[mid] è¿”å› æŠ˜åŠä¸‹æ ‡
        }
    }
    return -1;
    return -1;
}

int main() {
    //åˆå§‹åŒ–å¾…æŸ¥æ‰¾æ•°æ®
    SeqList source1[]={{0,9},{1,13},{2,15},{3,7},{4,45},{5,32},{6,56},{7,89},{8,60},{9,36}};
    SeqList source2[]={{0,5},{1,7},{2,9},{3,12},{4,15},{5,18},{6,20},{7,22},{8,25},{9,30},{10,100}};
    SeqList* source;
    //æŸ¥æ‰¾çš„æ•°æ®
    int finder;
    //æ•°æ®å¤§å°
    int size;
    //æŸ¥æ‰¾æ–¹å¼
    int way;
    //æŸ¥æ‰¾æ•°æ®é€‰æ‹©
    int data;
    //è¿”å›çš„ä¸‹æ ‡
    printf("ç¨‹åºå¼€å§‹***************************\\n");
    int result=-1;
    //æŸ¥æ‰¾å¼€å§‹
    printf("è¯·è¾“å…¥æŸ¥æ‰¾å†…å®¹ï¼š");
    scanf("%d",&finder);
    printf("è¯·é€‰æ‹©æŸ¥æ‰¾æ–¹å¼ï¼š\\n1:é¡ºåºæŸ¥æ‰¾\\n2:æŠ˜åŠæŸ¥æ‰¾\\n3:æ’å€¼æŸ¥æ‰¾");
    scanf("%d",&way);
    printf("è¯·é€‰æ‹©å¾…æŸ¥æ‰¾æ•°ç»„");
    scanf("%d",&data);
    if (data == 1){
        source = source1;
        size=9;
    }else if (data ==2){
        source = source2;
        size = 10;
    }
    while (finder != '-1'){
        //è¿”å›æŸ¥æ‰¾å†…å®¹ -1ï¼šæœªæ‰¾åˆ° å¦åˆ™è¿”å›ä¸‹æ ‡å¿—
        switch (way) {
            case 1:result= SeqSearch(source,size,finder);break;
            case 2:result= BinSearch(source,size,finder);break;
            case 3:result= interpolationSearch(source,size,finder);break;
            default:printf("è¾“å…¥é”™è¯¯,ç¨‹åºç»“æŸ");
        }
        if (result == -1)printf("æœªæŸ¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯\\n");
        else printf("æ‰€æŸ¥æ‰¾å…ƒç´ ä¸‹æ ‡å€¼ä¸º%d\\n",result);
        printf("è¯·è¾“å…¥æŸ¥æ‰¾å†…å®¹ï¼š");
        scanf("%d",&finder);
        printf("è¯·é€‰æ‹©æŸ¥æ‰¾æ–¹å¼ï¼š\\n1:é¡ºåºæŸ¥æ‰¾\\n2:æŠ˜åŠæŸ¥æ‰¾\\n3:æ’å€¼æŸ¥æ‰¾");
        scanf("%d",&way);
    }
    return 0;
}
```

### Javaæ–¹æ³•å®ç°

```java
package com.finder.oder;

import java.util.Scanner;

public class Main{
    public static void main(String args[]){
        int[] data = {9,13,15,7,45,32,56,89,60,36};
        int finder;
        int way;
        int result=-1;
        System.out.println("è¯·è¾“å…¥è¦æŸ¥æ‰¾çš„æ•°æ®ï¼ˆintï¼‰");
        Scanner input = new Scanner(System.in);
        finder = input.nextInt();
        way = input.nextInt();
        System.out.println("è¯·é€‰æ‹©æŸ¥æ‰¾æ–¹æ³•\\n1:é¡ºåºæŸ¥æ‰¾\\n2:ä¼˜åŒ–é¡ºåºæŸ¥æ‰¾\\n3ï¼šæŠ˜åŠæŸ¥æ‰¾\\n4.æ’å€¼æŸ¥æ‰¾");
        switch (way){
            case 1:result = sequentialSearch(data,finder);break;
            case 2:result = sequentialSearch2(data,finder);break;
            case 3:result = binarySearch(data,finder);break;
            case 4:result = interpolationSearch(data,finder);break;
            default:System.out.println("è¾“å…¥é”™è¯¯ï¼Œç¨‹åºç»“æŸ");
        }
        if (result != -1)System.out.println("ä¸‹æ ‡ä¸º"+result);
				else System.out.println("æœªæŸ¥æ‰¾åˆ°æ­¤æ•°æ®");
    }

    /**
     * é¡ºåºæŸ¥æ‰¾
     * @param a æ•°ç»„
     * @param key å¾…æŸ¥æ‰¾å…³é”®å­—
     * @return å…³é”®å­—ä¸‹æ ‡
     */
    public static int sequentialSearch(int[] a, int key) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] == key)
                return i;
        }
        return -1;
    }
    /**
     * æœ‰å“¨å…µé¡ºåºæŸ¥æ‰¾
     * @param a æ•°ç»„(ä¸‹æ ‡ä¸º0å­˜æ”¾å“¨å…µå…ƒç´ )
     * @param key å¾…æŸ¥è¯¢å…³é”®å­—
     * @return å…³é”®å­—ä¸‹æ ‡ è¿”å›0 åˆ™æœªæ‰¾åˆ°
     */
    public static int sequentialSearch2(int[] a, int key) {
        int index = a.length - 1;
        a[0] = key;// å°†ä¸‹æ ‡ä¸º0çš„æ•°ç»„å…ƒç´ è®¾ç½®ä¸ºå“¨å…µ
        while (a[index] != key) {
            index--;
        }
        return index;
    }
    /**
     * æŠ˜åŠæŸ¥æ‰¾
     * @param a æ•°ç»„
     * @param key å¾…æŸ¥æ‰¾å…³é”®å­—
     * @return è¿”å›æŠ˜åŠä¸‹æ ‡ï¼Œ -1è¡¨ç¤ºä¸å­˜åœ¨è¯¥å…³é”®å­—
     */

    public static int binarySearch(int[] a, int key) {
        int low, mid, high;
        low = 0;// æœ€å°ä¸‹æ ‡
        high = a.length - 1;// æœ€å¤§å°æ ‡
        while (low <= high) {
            mid = (high + low) / 2;// æŠ˜åŠä¸‹æ ‡
            if (key > a[mid]) {
                low = mid + 1; // å…³é”®å­—æ¯” æŠ˜åŠå€¼ å¤§ï¼Œåˆ™æœ€å°ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„ä¸‹ä¸€ä½
            } else if (key < a[mid]) {
                high = mid - 1;// å…³é”®å­—æ¯” æŠ˜åŠå€¼ å°ï¼Œåˆ™æœ€å¤§ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„å‰ä¸€ä½
            } else {
                return mid; // å½“ key == a[mid] è¿”å› æŠ˜åŠä¸‹æ ‡
            }
        }
        return -1;
    }
    /**
     * æ’å€¼æŸ¥æ‰¾
     * @param a æ•°ç»„
     * @param key å¾…æŸ¥æ‰¾å…³é”®å­—
     * @return è¿”å›æŠ˜åŠä¸‹æ ‡ï¼Œ -1è¡¨ç¤ºä¸å­˜åœ¨è¯¥å…³é”®å­—
     */
    public static int interpolationSearch(int[] a, int key) {
        int low, mid, high;
        low = 0;// æœ€å°ä¸‹æ ‡
        high = a.length - 1;// æœ€å¤§å°æ ‡
        while (low < high) {
            mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]);
            // mid = (high + low) / 2;// æŠ˜åŠä¸‹æ ‡
            if (key > a[mid]) {
                low = mid + 1; // å…³é”®å­—æ¯” æŠ˜åŠå€¼ å¤§ï¼Œåˆ™æœ€å°ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„ä¸‹ä¸€ä½
            } else if (key < a[mid]) {
                high = mid - 1;// å…³é”®å­—æ¯” æŠ˜åŠå€¼ å°ï¼Œåˆ™æœ€å¤§ä¸‹æ ‡ è°ƒæˆ æŠ˜åŠä¸‹æ ‡çš„å‰ä¸€ä½
            } else {
                return mid; // å½“ key == a[mid] è¿”å› æŠ˜åŠä¸‹æ ‡
            }
        }
        return -1;
    }
}
```

**å››ã€å®éªŒä»»åŠ¡**

è®¤çœŸé˜…è¯»ä¸ç†è§£å®éªŒå†…å®¹çš„å…·ä½“è¦æ±‚ï¼Œå‚è€ƒæ•™æç›¸å…³ç« èŠ‚ï¼Œç¼–å†™å®éªŒç¨‹åºå¹¶ä¸Šæœºè°ƒè¯•ä¸æµ‹è¯•ï¼Œå®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚

**1.å·²çŸ¥å«æœ‰10ä¸ªæ•´æ•°çš„æŸ¥æ‰¾è¡¨å¦‚ä¸‹ï¼šï¼ˆ9ï¼Œ13ï¼Œ15ï¼Œ7ï¼Œ45ï¼Œ32ï¼Œ56ï¼Œ89ï¼Œ60ï¼Œ36ï¼‰ï¼Œä»é”®ç›˜ä¸Šè¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œç”¨é¡ºåºæŸ¥æ‰¾çš„æ–¹æ³•åœ¨æŸ¥æ‰¾è¡¨ä¸­æŸ¥æ‰¾è¯¥æ•´æ•°ã€‚è‹¥å­˜åœ¨ï¼Œè¾“å‡ºè¯¥å…ƒç´ çš„ä¸‹æ ‡å€¼ï¼Œå¦åˆ™ï¼Œç»™å‡ºç›¸åº”çš„ä¿¡æ¯ã€‚**

**2.å¯¹æœ‰åºæ•°æ®è¡¨(5ï¼Œ7ï¼Œ9ï¼Œ12ï¼Œ15ï¼Œ18ï¼Œ20ï¼Œ22ï¼Œ25ï¼Œ30ï¼Œ100)ï¼Œç¼–å†™ç¨‹åºæŒ‰æŠ˜åŠæŸ¥æ‰¾æ–¹æ³•æŸ¥æ‰¾12å’Œ28ã€‚**

## å®éªŒå…«ã€æ’åºç®—æ³•çš„å®

## **ä¸€ã€å®éªŒç›®çš„**

1. æŒæ¡å¸¸ç”¨çš„æ’åºæ–¹æ³•ï¼Œå¹¶æŒæ¡ç”¨é«˜çº§è¯­è¨€å®ç°æ’åºç®—æ³•çš„æ–¹æ³•ï¼›
2. æ·±åˆ»ç†è§£æ’åºçš„å®šä¹‰å’Œå„ç§æ’åºæ–¹æ³•çš„ç‰¹ç‚¹ï¼Œå¹¶èƒ½åŠ ä»¥çµæ´»åº”ç”¨ï¼›
3. äº†è§£å„ç§æ–¹æ³•çš„æ’åºè¿‡ç¨‹åŠå…¶æ—¶é—´å¤æ‚åº¦çš„åˆ†ææ–¹æ³•ã€‚

## **äºŒã€å®éªŒè¦æ±‚**

ç»Ÿè®¡æˆç»©ï¼šç»™å‡ºnä¸ªå­¦ç”Ÿçš„è€ƒè¯•æˆç»©è¡¨ï¼Œæ¯æ¡ä¿¡æ¯ç”±å§“åå’Œåˆ†æ•°ç»„æˆï¼Œè¯•è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼š

ï¼ˆ1ï¼‰ æŒ‰åˆ†æ•°é«˜ä½æ¬¡åºï¼Œæ‰“å°å‡ºæ¯ä¸ªå­¦ç”Ÿåœ¨è€ƒè¯•ä¸­è·å¾—çš„åæ¬¡ï¼Œåˆ†æ•°ç›¸åŒçš„ä¸ºåŒä¸€åæ¬¡ï¼›

ï¼ˆ2ï¼‰ æŒ‰åæ¬¡åˆ—å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å§“åä¸åˆ†æ•°ã€‚

## **ä¸‰ã€å®éªŒæ­¥éª¤**

### 1.å®šä¹‰ç»“æ„ä½“ã€‚

```csharp
typedef  struct  student{ 
	char  name[8];
	int  score; 
}studentImform,*studentPtrï¼›
typedef struct student{
    char name[8];
    int score;
}studentImform,*studentPtr;
```

### 2.å®šä¹‰ç»“æ„ä½“æ•°ç»„ã€‚

```csharp
//ç›´æ¥æ•°ç»„
struct student students[MAX_SIZE];
studentImform students[MAX_SIZE];
//malloc åˆ†é…
studentPtr students = (studentPtr)malloc(sizeof(studentImform));
studentPtr students = (studentPtr)malloc(MAX_SIZE*sizeof(studentImform));
//ç›´æ¥æ•°ç»„
struct student Students[MAX_SIZE];
studentImform Students[MAX_SIZE];
studentImform Students[N];//Nç¡®å®šåc89\\99æ ‡å‡†ä¸­ä¸æ”¯æŒ

//åŠ¨æ€åˆ†é…
studentPtr Students = (studentPtr)malloc(sizeof(studentImform));
studentPtr Students = (studentPtr)malloc(sizeof(studentImform)*MAX_SIZE);
studentPtr Students = (studentPtr)malloc(sizeof(studentImform)*N);//Nç¡®å®šå
```

### 3.ç¼–å†™ä¸»ç¨‹åºï¼Œå¯¹æ•°æ®è¿›è¡Œæ’åºã€‚

### 4.è¦æ±‚è‡³å°‘é‡‡ç”¨ä¸¤ç§æ’åºç®—æ³•å®ç°ï¼Œå¦‚ç›´æ¥æ’å…¥æ’åºã€å¿«é€Ÿæ’åºç­‰ç®—æ³•ã€‚

4.1ç›´æ¥æ’å…¥æ’åºåŸºæœ¬æ€æƒ³

æ’åºè¿‡ç¨‹ï¼šé»˜è®¤åˆå§‹æ•°ç»„ä¸‹æ ‡ä¸º0çš„æ•°å­—ä¸ºæœ‰åºåºåˆ—ï¼Œæ¯æ¬¡ä»åç»­æ•°ç»„ä¸­é¡ºåºæ‹¿ä¸€ä¸ªæ•°å­—ï¼Œå°†è¿™ä¸ªæ•°å­—æ”¾åˆ°å‰é¢çš„æœ‰åºåºåˆ—ä¸­ï¼Œæ”¾çš„ä½ç½®è¦ç¡®ä¿æ”¾å®Œä¹‹åä¾æ—§æ˜¯æœ‰åºçš„ã€‚

å°†nä¸ªå…ƒç´ çš„æ•°åˆ—åˆ†ä¸ºå·²æœ‰åºå’Œæ— åºä¸¤ä¸ªéƒ¨åˆ†ï¼Œ

æ’å…¥æ’åºè¿‡ç¨‹ç¤ºä¾‹å¦‚ä¸‹æ‰€ç¤ºï¼š

```c
a1ï¼Œa2ï¼Œa3ï¼Œa4ï¼Œâ€¦ï¼Œan

a1ï¼Œa2ï¼Œa3ï¼Œa4ï¼Œâ€¦ï¼Œan

a1â‘´ï¼Œa2â‘´ï¼Œa3â‘´ï¼Œa4â‘´â€¦ï¼Œanâ‘´

a1â‘´ï¼Œa2â‘´ï¼Œa3â‘´ï¼Œa4â‘´â€¦ï¼Œanâ‘´

â€¦

â€¦

a1(nâˆ’1ï¼‰ï¼Œa2(nâˆ’1)ï¼Œâ€¦,an(nâˆ’1)

a1(nâˆ’1ï¼‰ï¼Œa2(nâˆ’1)ï¼Œâ€¦,an(nâˆ’1)
```

æ¯æ¬¡å¤„ç†å°±æ˜¯å°†æ— åºæ•°åˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸æœ‰åºæ•°åˆ—çš„å…ƒç´ ä»åå¾€å‰é€ä¸ªè¿›è¡Œæ¯”è¾ƒï¼Œæ‰¾å‡ºæ’å…¥ä½ç½®ï¼Œå°†è¯¥å…ƒç´ æ’å…¥åˆ°æœ‰åºæ•°åˆ—çš„åˆé€‚ä½ç½®ä¸­ã€‚

```c
void insertionSort(int *number,int n)
{
    int i=0,ii=0,temp=0;
    for(i=1;i<n;i++)  //å¾ªç¯éå†
    {
        temp=number[i];  //å°†tempæ¯ä¸€æ¬¡èµ‹å€¼ä¸ºnumber[i]
        ii=i-1;
        while(ii>=0 && temp>number[ii])   //è¿™é‡Œæ”¹é¡ºåº (tempåçš„)"<"ä¸ºå°åˆ°å¤§ï¼Œ">"ä¸ºå¤§åˆ°å°
        {
            number[ii+1]=number[ii];    //å°†å¤§çš„å…ƒç´ å¾€å‰æ”¾
            ii--;
        }
        number[ii+1]=temp;
    }
}

```

4.2 å¿«é€Ÿæ’åºåŸºæœ¬æ€æƒ³

åŸºæœ¬æ€æƒ³ï¼šæ˜¯å¯¹å†’æ³¡æ’åºçš„ä¸€ç§æ”¹è¿›ã€‚[1](https://blog.csdn.net/sty20030818/article/details/81272174#fn:1)å¿«é€Ÿæ’åºç”±C. A. R. Hoareåœ¨1962å¹´æå‡ºã€‚å®ƒçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé€šè¿‡ä¸€è¶Ÿæ’åºå°†è¦æ’åºçš„æ•°æ®åˆ†å‰²æˆç‹¬ç«‹çš„ä¸¤éƒ¨åˆ†ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æ•°æ®éƒ½æ¯”å¦å¤–ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æ•°æ®éƒ½è¦å°ï¼Œç„¶åå†æŒ‰æ­¤æ–¹æ³•å¯¹è¿™ä¸¤éƒ¨åˆ†æ•°æ®åˆ†åˆ«è¿›è¡Œå¿«é€Ÿæ’åºï¼Œæ•´ä¸ªæ’åºè¿‡ç¨‹å¯ä»¥é€’å½’è¿›è¡Œï¼Œä»¥æ­¤è¾¾åˆ°æ•´ä¸ªæ•°æ®å˜æˆæœ‰åºåºåˆ—ã€‚

æ’åºè¿‡ç¨‹ï¼šå¯¹r[sâ€¦â€¦t]ä¸­è®°å½•è¿›è¡Œä¸€è¶Ÿå¿«é€Ÿæ’åºï¼Œé™„è®¾ä¸¤ä¸ªæŒ‡é’ˆiå’Œjï¼Œè®¾rp=r[s]ï¼Œx=rp.keyã€‚åˆå§‹æ—¶ä»¤i=s,j=tã€‚é¦–å…ˆä»jæ‰€æŒ‡ä½ç½®å‘å‰æœç´¢ç¬¬ä¸€ä¸ªå…³é”®å­—å°äºxçš„è®°å½•ï¼Œå¹¶å’Œrpäº¤æ¢ã€‚å†ä»iæ‰€æŒ‡ä½ç½®èµ·å‘åæœç´¢ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå…³é”®å­—å¤§äºxçš„è®°å½•ï¼Œå’Œrpäº¤æ¢ã€‚é‡å¤ä¸Šè¿°ä¸¤æ­¥ï¼Œç›´è‡³i=jä¸ºæ­¢ã€‚å†åˆ†åˆ«å¯¹ä¸¤ä¸ªå­åºåˆ—è¿›è¡Œå¿«é€Ÿæ’åºï¼Œç›´åˆ°æ¯ä¸ªå­åºåˆ—åªå«æœ‰ä¸€ä¸ªè®°å½•ä¸ºæ­¢ã€‚

**æ’åºæ¼”ç¤ºç¤ºä¾‹**

å‡è®¾ç”¨æˆ·è¾“å…¥äº†å¦‚ä¸‹æ•°ç»„ï¼š

[Untitled](https://www.notion.so/62d86bf32d3b47adb93f0d100d2a7cbc)

åˆ›å»ºå˜é‡ i=0 ï¼ˆæŒ‡å‘ç¬¬ä¸€ä¸ªæ•°æ®ï¼‰,j=5(æŒ‡å‘æœ€åä¸€ä¸ªæ•°æ®), k=6(èµ‹å€¼ä¸ºç¬¬ä¸€ä¸ªæ•°æ®çš„å€¼)ã€‚

æˆ‘ä»¬è¦æŠŠæ‰€æœ‰æ¯”kå°çš„æ•°ç§»åŠ¨åˆ°kçš„å·¦é¢ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¼€å§‹å¯»æ‰¾æ¯”6å°çš„æ•°ï¼Œä»jå¼€å§‹ï¼Œä»å³å¾€å·¦æ‰¾ï¼Œä¸æ–­é€’å‡å˜é‡jçš„å€¼ï¼Œæˆ‘ä»¬æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸‹æ ‡3çš„æ•°æ®æ¯”6å°ï¼Œäºæ˜¯æŠŠæ•°æ®3ç§»åˆ°ä¸‹æ ‡0çš„ä½ç½®ï¼ŒæŠŠä¸‹æ ‡0çš„æ•°æ®6ç§»åˆ°ä¸‹æ ‡3ï¼Œå®Œæˆç¬¬ä¸€æ¬¡æ¯”è¾ƒï¼š

[Untitled](https://www.notion.so/d9f02f61ec7e47d5bad7ce2e57ab1e05)

i=0 , j=3 , k=6

æ¥ç€ï¼Œå¼€å§‹ç¬¬äºŒæ¬¡æ¯”è¾ƒï¼Œè¿™æ¬¡è¦å˜æˆæ‰¾æ¯”kå¤§çš„äº†ï¼Œè€Œä¸”è¦ä»å‰å¾€åæ‰¾äº†ã€‚é€’åŠ å˜é‡iï¼Œå‘ç°ä¸‹æ ‡2çš„æ•°æ®æ˜¯ç¬¬ä¸€ä¸ªæ¯”kå¤§çš„ï¼Œäºæ˜¯ç”¨ä¸‹æ ‡2çš„æ•°æ®7å’ŒjæŒ‡å‘çš„ä¸‹æ ‡3çš„æ•°æ®çš„6åšäº¤æ¢ï¼Œæ•°æ®çŠ¶æ€å˜æˆä¸‹è¡¨ï¼š

[Untitled](https://www.notion.so/065ba763324e41c69e1030aeba7e487e)

i=2 , j=3 ,k=6

ç§°ä¸Šé¢ä¸¤æ¬¡æ¯”è¾ƒä¸ºä¸€ä¸ªå¾ªç¯ã€‚

æ¥ç€ï¼Œå†é€’å‡å˜é‡jjï¼Œä¸æ–­é‡å¤è¿›è¡Œä¸Šé¢çš„å¾ªç¯æ¯”è¾ƒã€‚

åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬è¿›è¡Œä¸€æ¬¡å¾ªç¯ï¼Œå°±å‘ç°iiå’Œjj â€œç¢°å¤´â€äº†ï¼šä»–ä»¬éƒ½æŒ‡å‘äº†ä¸‹æ ‡22ã€‚äºæ˜¯ï¼Œç¬¬ä¸€éæ¯”è¾ƒç»“æŸã€‚å¾—åˆ°ç»“æœå¦‚ä¸‹ï¼Œå‡¡æ˜¯k(=6)k(=6)å·¦è¾¹çš„æ•°éƒ½æ¯”å®ƒå°ï¼Œå‡¡æ˜¯kkå³è¾¹çš„æ•°éƒ½æ¯”å®ƒå¤§ï¼š

[Untitled](https://www.notion.so/e09113924eb34fd8aa516cd5e08cdc14)

å¦‚æœiiå’Œjjæ²¡æœ‰ç¢°å¤´çš„è¯ï¼Œå°±é€’åŠ iæ‰¾å¤§çš„ï¼Œè¿˜æ²¡æœ‰ï¼Œå°±å†é€’å‡jæ‰¾å°çš„ï¼Œå¦‚æ­¤åå¤ï¼Œä¸æ–­å¾ªç¯ã€‚æ³¨æ„åˆ¤æ–­å’Œå¯»æ‰¾æ˜¯åŒæ—¶è¿›è¡Œçš„ã€‚

ç„¶åï¼Œå¯¹kä¸¤è¾¹çš„æ•°æ®ï¼Œå†åˆ†ç»„åˆ†åˆ«è¿›è¡Œä¸Šè¿°çš„è¿‡ç¨‹ï¼Œç›´åˆ°ä¸èƒ½å†åˆ†ç»„ä¸ºæ­¢ã€‚

æ³¨æ„ï¼šç¬¬ä¸€éå¿«é€Ÿæ’åºä¸ä¼šç›´æ¥å¾—åˆ°æœ€ç»ˆç»“æœï¼Œåªä¼šæŠŠæ¯”kkå¤§å’Œæ¯”kkå°çš„æ•°åˆ†åˆ°kkçš„ä¸¤è¾¹ã€‚ä¸ºäº†å¾—åˆ°æœ€åç»“æœï¼Œéœ€è¦å†æ¬¡å¯¹ä¸‹æ ‡ä¸¤è¾¹çš„æ•°ç»„åˆ†åˆ«æ‰§è¡Œæ­¤æ­¥éª¤ï¼Œç„¶åå†åˆ†è§£æ•°ç»„ï¼Œç›´åˆ°æ•°ç»„ä¸èƒ½å†åˆ†è§£ä¸ºæ­¢ï¼ˆåªæœ‰ä¸€ä¸ªæ•°æ®ï¼‰ï¼Œæ‰èƒ½å¾—åˆ°æ­£ç¡®ç»“æœã€‚

```c
void quickSortIn(int left,int right,int a[]);
{
    if(left>=right)  //å¦‚æœå·¦è¾¹ç´¢å¼•å¤§äºæˆ–è€…ç­‰äºå³è¾¹çš„ç´¢å¼•å°±ä»£è¡¨å·²ç»æ•´ç†å®Œæˆä¸€ä¸ªç»„äº†
        return ;
    int i=left;     //å°†åŒºé—´è®°å½•ä¸‹æ¥ 
    int j=right;
    int key=a[i];    //è®°å½•å‚è€ƒå€¼ 
    while(i<j)   //æ§åˆ¶åœ¨å½“ç»„å†…å¯»æ‰¾ä¸€é
    {
        while(i<j&&key<=a[j])   //è€Œå¯»æ‰¾ç»“æŸçš„æ¡ä»¶å°±æ˜¯ï¼Œ1ï¼Œæ‰¾åˆ°ä¸€ä¸ªå°äºæˆ–è€…å¤§äºkeyçš„æ•°ï¼ˆå¤§äºæˆ–å°äºå–å†³äºä½ æƒ³å‡åºè¿˜æ˜¯é™åºï¼‰2ï¼Œæ²¡æœ‰ç¬¦åˆæ¡ä»¶1çš„ï¼Œå¹¶ä¸”iä¸jçš„å¤§å°æ²¡æœ‰åè½¬ 
            j--;    //å‘å‰å¯»æ‰¾
        a[i]=a[j];     //æ‰¾åˆ°ä¸€ä¸ªè¿™æ ·çš„æ•°åå°±æŠŠå®ƒèµ‹ç»™å‰é¢çš„è¢«æ‹¿èµ°çš„içš„å€¼ï¼ˆå¦‚æœç¬¬ä¸€æ¬¡å¾ªç¯ä¸”keyæ˜¯a[left]ï¼Œé‚£ä¹ˆå°±æ˜¯ç»™keyï¼‰
        while(i<j&&key>=a[i])   //è¿™æ˜¯iåœ¨å½“ç»„å†…å‘å‰å¯»æ‰¾ï¼ŒåŒä¸Šï¼Œä¸è¿‡æ³¨æ„ä¸keyçš„å¤§å°å…³ç³»åœæ­¢å¾ªç¯å’Œä¸Šé¢ç›¸åï¼Œå› ä¸ºæ’åºæ€æƒ³æ˜¯æŠŠæ•°å¾€ä¸¤è¾¹æ‰”ï¼Œæ‰€ä»¥å·¦å³ä¸¤è¾¹çš„æ•°å¤§å°ä¸keyçš„å…³ç³»ç›¸å
            i++;
        a[j]=a[i];
    }
    a[i]=key;                  //å½“åœ¨å½“ç»„å†…æ‰¾å®Œä¸€éä»¥åå°±æŠŠä¸­é—´æ•°keyå›å½’
    quickSortIn(left,i-1,a);     //æœ€åç”¨åŒæ ·çš„æ–¹å¼å¯¹åˆ†å‡ºæ¥çš„å·¦è¾¹çš„å°ç»„è¿›è¡ŒåŒä¸Šçš„åšæ³•
    quickSortIn(i+1,right,a);    //ç”¨åŒæ ·çš„æ–¹å¼å¯¹åˆ†å‡ºæ¥çš„å³è¾¹çš„å°ç»„è¿›è¡ŒåŒä¸Šçš„åšæ³•
                               //å½“ç„¶æœ€åå¯èƒ½ä¼šå‡ºç°å¾ˆå¤šåˆ†å·¦å³ï¼Œç›´åˆ°æ¯ä¸€ç»„çš„i = j ä¸ºæ­¢
}

void quickSort(int a[],int n){
	quickSortIn(0,n,int a[]);
}
```

### 4.3 é€‰æ‹©æ’åº

æ˜¯ä¸€ç§ç®€å•ç›´è§‚çš„æ’åºç®—æ³•ã€‚1å®ƒçš„å·¥ä½œåŸç†æ˜¯æ¯ä¸€æ¬¡ä»å¾…æ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰å‡ºæœ€å°ï¼ˆæˆ–æœ€å¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ï¼Œå­˜æ”¾åœ¨åºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œç›´åˆ°å…¨éƒ¨å¾…æ’åºçš„æ•°æ®å…ƒç´ æ’å®Œã€‚ é€‰æ‹©æ’åºæ˜¯ä¸ç¨³å®šçš„æ’åºæ–¹æ³•ï¼ˆæ¯”å¦‚åºåˆ—[5ï¼Œ 5ï¼Œ 3]ç¬¬ä¸€æ¬¡å°±å°†ç¬¬ä¸€ä¸ª[5]ä¸[3]äº¤æ¢ï¼Œå¯¼è‡´ç¬¬ä¸€ä¸ª5æŒªåŠ¨åˆ°ç¬¬äºŒä¸ª5åé¢ï¼‰ã€‚

```c
void selectSort(int R[],int n)    //å®šä¹‰é€‰æ‹©æ’åºå‡½æ•°"select_sort"
{
    int i, j, k, index;
    for (i = 0; i < n - 1; i++) {
        k = i;
        for (j = i + 1; j < n; j++)    //jåˆå§‹ä¸ä¸º0ï¼Œå†’æ³¡åˆå§‹ä¸º0ï¼Œæ‰€ä»¥é€‰æ’æ¯”å†’æ³¡å¿«ï¼Œä½†ä¸ç¨³å®š
        {
            if (R[j] > R[k])   //é¡ºåºä»è¿™é‡Œæ”¹é¡ºåº å°åˆ°å¤§"<",å¤§åˆ°å°">"
                k = j;      //è¿™é‡Œæ˜¯åŒºåˆ†å†’æ³¡æ’åºä¸é€‰æ‹©æ’åºçš„åœ°æ–¹ï¼Œå†’æ³¡æ²¡è¿™å¥
        }
        index = R[i];   //äº¤æ¢R[i]ä¸R[k]ä¸­çš„æ•°
        R[i] = R[k];    //ç®€å•çš„äº¤æ¢c=a,a=b,b=c
        R[k] = index;
    }
}
```

### 4.4å†’æ³¡æ’åº

å®ƒé‡å¤åœ°èµ°è®¿è¿‡è¦æ’åºçš„å…ƒç´ åˆ—ï¼Œä¸€æ¬¡æ¯”è¾ƒä¸¤ä¸ªç›¸é‚»çš„å…ƒç´ ï¼Œå¦‚æœä»–ä»¬çš„é¡ºåºï¼ˆå¦‚ä»å¤§åˆ°å°ã€é¦–å­—æ¯ä»Aåˆ°Zï¼‰é”™è¯¯å°±æŠŠä»–ä»¬äº¤æ¢è¿‡æ¥ã€‚èµ°è®¿å…ƒç´ çš„å·¥ä½œæ˜¯é‡å¤åœ°è¿›è¡Œç›´åˆ°æ²¡æœ‰ç›¸é‚»å…ƒç´ éœ€è¦äº¤æ¢ï¼Œä¹Ÿå°±æ˜¯è¯´è¯¥å…ƒç´ å·²ç»æ’åºå®Œæˆã€‚è¿™ä¸ªç®—æ³•çš„åå­—ç”±æ¥æ˜¯å› ä¸ºè¶Šå¤§çš„å…ƒç´ ä¼šç»ç”±äº¤æ¢æ…¢æ…¢â€œæµ®â€åˆ°æ•°åˆ—çš„é¡¶ç«¯ï¼ˆå‡åºæˆ–é™åºæ’åˆ—ï¼‰ï¼Œå°±å¦‚åŒç¢³é…¸é¥®æ–™ä¸­äºŒæ°§åŒ–ç¢³çš„æ°”æ³¡æœ€ç»ˆä¼šä¸Šæµ®åˆ°é¡¶ç«¯ä¸€æ ·ï¼Œæ•…åâ€œå†’æ³¡æ’åºâ€ã€‚

å†’æ³¡æ’åºç®—æ³•çš„åŸç†å¦‚ä¸‹ï¼š

1.æ¯”è¾ƒç›¸é‚»çš„å…ƒç´ ã€‚å¦‚æœç¬¬ä¸€ä¸ªæ¯”ç¬¬äºŒä¸ªå¤§ï¼Œå°±äº¤æ¢ä»–ä»¬ä¸¤ä¸ªï¼Œè¿™æ ·æ˜¯ä»å°åˆ°å¤§æ’ã€‚

(å¦‚æœç¬¬ä¸€ä¸ªæ¯”ç¬¬äºŒä¸ªå°ï¼Œäº¤æ¢ , é‚£å°±æ˜¯ä»å¤§åˆ°å°æ’)

2.å¯¹æ¯ä¸€å¯¹ç›¸é‚»å…ƒç´ åšåŒæ ·çš„å·¥ä½œï¼Œä»å¼€å§‹ç¬¬ä¸€å¯¹åˆ°ç»“å°¾çš„æœ€åä¸€å¯¹ã€‚åœ¨è¿™ä¸€ç‚¹ï¼Œæœ€åçš„å…ƒç´ åº”è¯¥ä¼šæ˜¯æœ€å¤§çš„æ•°ã€‚

3.é’ˆå¯¹æ‰€æœ‰çš„å…ƒç´ é‡å¤ä»¥ä¸Šçš„æ­¥éª¤ï¼Œé™¤äº†æœ€åä¸€ä¸ªã€‚

4.æŒç»­æ¯æ¬¡å¯¹è¶Šæ¥è¶Šå°‘çš„å…ƒç´ é‡å¤ä¸Šé¢çš„æ­¥éª¤ï¼Œç›´åˆ°æ²¡æœ‰ä»»ä½•ä¸€å¯¹æ•°å­—éœ€è¦æ¯”è¾ƒã€‚

```c
void bubbleSort(int a[], int n)    //ä¸‹é¢æ˜¯å‡½æ•°bubble_sortçš„ç¨‹åº 
{
    int i,j,temp;    //å®šä¹‰ä¸‰ä¸ªæ•´å‹å˜é‡ 
    for (j=0;j<n-1;j++)    //ç”¨ä¸€ä¸ªåµŒå¥—å¾ªç¯æ¥éå†ä¸€éæ¯ä¸€å¯¹ç›¸é‚»å…ƒç´  ï¼ˆæ‰€ä»¥å†’æ³¡å‡½æ•°æ…¢å˜›ï¼Œæ—¶é—´å¤æ‚åº¦é«˜ï¼‰  
    {                           
        for (i=0;i<n-1-j;i++)
        {
            if(a[i]>a[i+1])  //ä»å¤§åˆ°å°æ’å°±æŠŠå·¦è¾¹çš„">"æ”¹ä¸º"<" ï¼ï¼ï¼
            {
                temp=a[i];      //a[i]ä¸a[i+1](å³a[i]åé¢é‚£ä¸ª) äº¤æ¢
                a[i]=a[i+1];    //åŸºæœ¬çš„äº¤æ¢åŸç†"c=a;a=b;b=c" 
                a[i+1]=temp;
            }
        }
    }    
}
```

## å®Œæ•´æºä»£ç 

```c
#include <stdio.h>
#include <stdlib.h>

//å­¦ç”Ÿæœ€å¤§è¾“å…¥é‡
#define MAX_SIZE 100

//å­¦ç”Ÿä¿¡æ¯ç»“æ„ä½“
typedef struct student{
    char name[8];
    int score;
}studentImform,*studentPtr;

//æ’å…¥æ’åº
void insertionSort(studentPtr number,int n)
{
    int i=0,ii=0;
    studentImform temp;
    for(i=1;i<n;i++)
    {
        temp = number[i];
        ii=i-1;
        while(ii>=0 && temp.score >number[ii].score)
        {
            number[ii+1]=number[ii];
            ii--;
        }
        number[ii+1]=temp;
    }
}
void bubbleSort(studentPtr a, int n)
{
    int i,j;
    studentImform temp;
    for (j=0;j<n-1;j++)
    {
        for (i=0;i<n-1-j;i++)
        {
            if(a[i].score < a[i+1].score)
            {
                temp = a[i];
                a[i] = a[i+1];
                a[i+1] = temp;
            }
        }
    }
}

//é€‰æ‹©æ’åºæ³•
void selectSort(studentPtr R,int n)
{
    int i, j, k;
    studentImform index;
    for (i = 0; i < n - 1; i++) {
        k = i;
        for (j = i + 1; j < n; j++)
        {
            if (R[j].score > R[k].score)
                k = j;
        }
        index = R[i];
        R[i] = R[k];
        R[k] = index;
    }
}

//å¿«é€Ÿæ’åºæ³•
void quicksortIn(int left,int right,studentPtr a)
{
    if(left >= right) return ;
    int i=left;
    int j=right;

    studentImform key=a[i];

    while(i<j)
    {
    while(i<j && key.score >= a[j].score)
        j--;
        a[i]=a[j];
    while(i<j && key.score <= a[i].score)
        i++;
        a[j]=a[i];
    }
    a[i] = key;
    quicksortIn(left,i-1,a);
    quicksortIn(i+1,right,a);
    }
void quickSort(studentPtr a,int n){
    quicksortIn(0,n+1,a);
}
int main(){
    //å®šä¹‰å˜é‡
    int N,i=0,way;
    studentImform Students[MAX_SIZE] = {0};
    //è¾“å…¥ä¿¡æ¯
    printf("è¯·è¾“å…¥å­¦ç”Ÿæ•°é‡\\n");
    scanf("%d",&N);

    while (N<=0){
        printf("è¾“å…¥ä¸åˆæ³•ï¼Œè¯·é‡æ–°è¾“å…¥\\n");
        scanf("%d",&N);
    }
    printf("è¯·ä¾æ¬¡è¾“å…¥%då­¦ç”Ÿçš„å§“ååŠæˆç»©\\n",N);
    for (int j= 0; j < N; ++j) {
        scanf("%s",Students[j].name);
        scanf("%d",&Students[j].score);
        while (Students[i].name == NULL || Students[j].score<0){
            printf("è¾“å…¥ä¸åˆæ³•ï¼Œè¯·é‡æ–°è¾“å…¥%dä½åŒå­¦çš„ä¿¡æ¯\\n",j+1);
            scanf("%s",Students[j].name);
            scanf("%d",&Students[j].score);
        }
    }
    printf("è¯·é€‰æ‹©æ’åºæ–¹å¼:\\n1.ç›´æ¥æ’å…¥æ’åº\\n2.å¿«é€Ÿæ’åº\\n3.é€‰æ‹©æ’åº\\n4.\\n");
    scanf("%d",&way);
    switch (way) {
        case 1:
            insertionSort(Students,N);
            break;
        case 2:
            quickSort(Students,N);
            break;
        case 3:
            selectSort(Students,N);
            break;
        case 4:
            bubbleSort(Students,N);
        default:
            printf("è¾“å…¥æœ‰è¯¯\\n");
    }
    printf("\\tåºå·  \\tå§“å\\t:  \\tåˆ†æ•°\\n");
    for (int j = 0; j < N; ++j) {
        printf("\\t%-d\\t%-s\\t:\\t%-d\\n",j,Students[j].name,Students[j].score);
    }

}
```

## è€å¸ˆæ ‡å‡†å­å‡½æ•°

```c

```

**å››ã€å®éªŒä»»åŠ¡**

è®¤çœŸé˜…è¯»ä¸ç†è§£å®éªŒå†…å®¹çš„å…·ä½“è¦æ±‚ï¼Œå‚è€ƒæ•™æç›¸å…³ç« èŠ‚ï¼Œç¼–å†™å®éªŒç¨‹åºå¹¶ä¸Šæœºè°ƒè¯•ä¸æµ‹è¯•ï¼Œå®Œæˆå®éªŒæŠ¥å‘Šçš„æ’°å†™ã€‚